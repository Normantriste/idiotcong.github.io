<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>袁晓聪的个人网站</title>
  
  <subtitle>Nothing is nothing,simplify is best!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.normantriste.top/"/>
  <updated>2017-11-30T02:54:55.248Z</updated>
  <id>http://www.normantriste.top/</id>
  
  <author>
    <name>袁晓聪</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Oracle索引</title>
    <link href="http://www.normantriste.top/2017/11/30/%E5%85%B3%E4%BA%8EOracle%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.normantriste.top/2017/11/30/关于Oracle索引/</id>
    <published>2017-11-30T02:43:00.000Z</published>
    <updated>2017-11-30T02:54:55.248Z</updated>
    
    <content type="html"><![CDATA[<p>１．什么是索引？<br>&emsp;&emsp;索引是建立在表的一列或多个列上的辅助对象，目的是加快访问表中的数据;<br><a id="more"></a><br>&emsp;&emsp;Oracle存储索引的数据结构是B<em>树（平衡树），位图索引也是如此，只不过是叶子节点不同B</em>数索引；<br>&emsp;&emsp;索引由根节点、分支节点和叶子节点组成，上级索引块包含下级索引块的索引数据，叶节点包含索引数据和确定行实际位置的rowid。<br>2.使用索引的目的：<br>加快查询速度<br>减少I/O操作<br>消除磁盘排序（索引能加快排序速度）  </p><p>二、索引的几种常见用法  </p><p>1、创建索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">index</span> &lt;index_name&gt; <span class="keyword">on</span> &lt;table_name&gt;(&lt;colum_name&gt;) [<span class="keyword">tablespace</span>&lt;tablespace_name&gt;];</div></pre></td></tr></table></figure></p><p>2、重置索引<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert index&lt;index_name&gt; rebuid;</div></pre></td></tr></table></figure></p><p>3、删除索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">drop</span> <span class="keyword">index</span>&lt;index_name&gt;</div></pre></td></tr></table></figure></p><p>实例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">as</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span>,</div><div class="line">to_char(<span class="keyword">sysdate</span> + <span class="keyword">rownum</span>/<span class="number">24</span>/<span class="number">3600</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) <span class="keyword">as</span> ttime,</div><div class="line">trunc(dbms_random.value(<span class="number">0</span>,<span class="number">100</span>)) <span class="keyword">as</span> random_id,</div><div class="line">dbms_random.string(<span class="string">'x'</span>,<span class="number">20</span>) txt</div><div class="line"><span class="keyword">from</span> dual</div><div class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">20000000</span>;</div><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">from</span> <span class="keyword">test</span>;</div><div class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> txt=<span class="string">'2W8U82V49FKZYK0JQETF'</span>;</div><div class="line"><span class="keyword">drop</span> <span class="keyword">table</span>  <span class="keyword">test</span>;</div></pre></td></tr></table></figure></p><p>二、索引的分类<br>1、普通索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create index index_text_txt on test(txt);</div></pre></td></tr></table></figure></p><p>2、唯一索引 Oracle 自动在表的主键上创建唯一索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create unique index &lt;index_name&gt; on &lt;index_name&gt;(&lt;coiumn_name&gt;);</div></pre></td></tr></table></figure></p><p>3、位图索引<br>作用范围及优点：<br>1、位图索引适合创建在低级数列（重复的数值多，如性别）上<br>2、减少响应时间<br>3、节省空间占用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create bitmap index &lt;index_name&gt; on &lt;table_name&gt;(&lt;column_name&gt;)</div></pre></td></tr></table></figure></p><p>4、组合索引<br>作用范围及优点：<br>1、组合索引是在表的多个列上创建的索引<br>2、索引中的顺序是任意的<br>3、如果SQL语言的WHERE子句中引用了组合索引的所有或大多数列，则可以提高检索速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create index &lt;index_name&gt; on &lt;table_name&gt;(&lt;column_name1&gt;&lt;column_name2&gt;)</div></pre></td></tr></table></figure></p><p>5、基于函数索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create index &lt;index_name&gt; on &lt;table_name&gt;(&lt;function_name&gt;(&lt;column_name&gt;));</div></pre></td></tr></table></figure></p><p>6、反向键索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create index &lt;index_name&gt; on &lt;table_name&gt;(column_name) reverse;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;１．什么是索引？&lt;br&gt;&amp;emsp;&amp;emsp;索引是建立在表的一列或多个列上的辅助对象，目的是加快访问表中的数据;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>(补充)Spring编码过滤器</title>
    <link href="http://www.normantriste.top/2017/11/09/%E8%A1%A5%E5%85%85-Spring%E7%BC%96%E7%A0%81%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>http://www.normantriste.top/2017/11/09/补充-Spring编码过滤器/</id>
    <published>2017-11-09T00:55:00.000Z</published>
    <updated>2017-11-09T00:55:55.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在web-xml中添加配置"><a href="#在web-xml中添加配置" class="headerlink" title="在web.xml中添加配置"></a>在web.xml中添加配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 编码过滤器 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 指定编码--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在web-xml中添加配置&quot;&gt;&lt;a href=&quot;#在web-xml中添加配置&quot; class=&quot;headerlink&quot; title=&quot;在web.xml中添加配置&quot;&gt;&lt;/a&gt;在web.xml中添加配置&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;
      
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第7章 RESTful支持</title>
    <link href="http://www.normantriste.top/2017/11/09/%E7%AC%AC7%E7%AB%A0-RESTful%E6%94%AF%E6%8C%81/"/>
    <id>http://www.normantriste.top/2017/11/09/第7章-RESTful支持/</id>
    <published>2017-11-09T00:53:00.000Z</published>
    <updated>2017-11-09T00:54:18.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RESTful支持"><a href="#RESTful支持" class="headerlink" title="RESTful支持"></a>RESTful支持</h2><h3 id="什么是RESUful"><a href="#什么是RESUful" class="headerlink" title="什么是RESUful"></a>什么是RESUful</h3><p>– RESTful（即Representational State Transfer的缩写）<br>其实是一个开发理念，是对http的很好的诠释。<br>– RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以得到越<br>来越多网站的采用。<br><a id="more"></a></p><h3 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h3><p>– 每一个URI代表一种资源<br>– 客户端和服务器之间，传递这种资源的某种表现层<br>– 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”   </p><h3 id="对url进行规范，写RESTful格式的url"><a href="#对url进行规范，写RESTful格式的url" class="headerlink" title="对url进行规范，写RESTful格式的url"></a>对url进行规范，写RESTful格式的url</h3><p>– 非REST的url：<br><a href="http://...../queryItems.action?id=001&amp;type=T01" target="_blank" rel="external">http://...../queryItems.action?id=001&amp;type=T01</a><br>– REST的url风格：<a href="http://..../items/001" target="_blank" rel="external">http://..../items/001</a><br>– 特点：url简洁，将参数通过url传到服务端</p><h3 id="http的方法规范"><a href="#http的方法规范" class="headerlink" title="http的方法规范"></a>http的方法规范</h3><p>– 不管是删除、添加、更新。使用url是一致的，如果进行删除，需要设置http的方法为delete，同理添加。<br>– 后台controller方法：判断http方法，如果是delete执行删除，如果是post执行添加。</p><h3 id="对http的contentType规范"><a href="#对http的contentType规范" class="headerlink" title="对http的contentType规范"></a>对http的contentType规范</h3><p>– 请求时指定contentType，要json数据，设置成json格式的type。  </p><h2 id="配置REST方法的前端控制器"><a href="#配置REST方法的前端控制器" class="headerlink" title="配置REST方法的前端控制器"></a>配置REST方法的前端控制器</h2><p>– 在web.xml中配置<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/restful-web.xml%E9%85%8D%E7%BD%AE.png" alt="image">  </p><h3 id="URL-模板模式映射"><a href="#URL-模板模式映射" class="headerlink" title="URL 模板模式映射"></a>URL 模板模式映射</h3><p>– @RequestMapping(value=”/itemsView/{id}”)：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。<br>– @PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。<br>– 如果RequestMapping中表示为”/itemsView/{id}”，id和形参名称一致，@PathVariable不用指定名称。  </p><h3 id="controller定义方法，进行url映射使用REST风格的url"><a href="#controller定义方法，进行url映射使用REST风格的url" class="headerlink" title="controller定义方法，进行url映射使用REST风格的url"></a>controller定义方法，进行url映射使用REST风格的url</h3><p><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/restful-controller%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95.png" alt="image"></p><h3 id="对静态资源的解析"><a href="#对静态资源的解析" class="headerlink" title="对静态资源的解析"></a>对静态资源的解析</h3><p>– 配置前端控制器的url-parttern中指定/，对静态资源的解析出现问题：<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/restful-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%901.png" alt="image"><br>– 在springmvc.xml中添加静态资源解析方法。<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/restful-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%902.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RESTful支持&quot;&gt;&lt;a href=&quot;#RESTful支持&quot; class=&quot;headerlink&quot; title=&quot;RESTful支持&quot;&gt;&lt;/a&gt;RESTful支持&lt;/h2&gt;&lt;h3 id=&quot;什么是RESUful&quot;&gt;&lt;a href=&quot;#什么是RESUful&quot; class=&quot;headerlink&quot; title=&quot;什么是RESUful&quot;&gt;&lt;/a&gt;什么是RESUful&lt;/h3&gt;&lt;p&gt;– RESTful（即Representational State Transfer的缩写）&lt;br&gt;其实是一个开发理念，是对http的很好的诠释。&lt;br&gt;– RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以得到越&lt;br&gt;来越多网站的采用。&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第7章 文件上传和json数据交互</title>
    <link href="http://www.normantriste.top/2017/11/09/%E7%AC%AC7%E7%AB%A0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%92%8Cjson%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/"/>
    <id>http://www.normantriste.top/2017/11/09/第7章-文件上传和json数据交互/</id>
    <published>2017-11-09T00:52:00.000Z</published>
    <updated>2017-11-09T00:53:15.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>– 导入jar包<br>– 创建虚拟目录<br>– 配置解析器<br>– 编写controller代码<br>– 编写页面代码<br><a id="more"></a></p><h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><p>commons-fileupload-1.2.2.jar<br>commons-io-2.4.jar  </p><h3 id="配置虚拟目录存储图片"><a href="#配置虚拟目录存储图片" class="headerlink" title="配置虚拟目录存储图片"></a>配置虚拟目录存储图片</h3><p>– 在tomcat上配置图片虚拟目录，在tomcat下conf/server.xml中添加<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95.png" alt="image"></p><p>– 访问<a href="http://localhost:8080/pic即可访问" target="_blank" rel="external">http://localhost:8080/pic即可访问</a><br>D:\eclipsejuno2\springmvc_mybatis_upload01\temp下的图片</p><h3 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h3><p>– 在springmvc.xml中配置<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%99%A8.png" alt="image"></p><h3 id="controller代码"><a href="#controller代码" class="headerlink" title="controller代码"></a>controller代码</h3><p><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-controller%E4%BB%A3%E7%A0%81.png" alt="image"></p><h3 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h3><p><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-form%E8%A1%A8%E5%8D%951.png" alt="image"><br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-form%E8%A1%A8%E5%8D%952.png" alt="image"></p><h2 id="json数据交互"><a href="#json数据交互" class="headerlink" title="json数据交互"></a>json数据交互</h2><h3 id="json交互概述"><a href="#json交互概述" class="headerlink" title="json交互概述"></a>json交互概述</h3><p>– json数据格式在接口调用中、html页面中较常用，json格<br>式比较简单，解析还比较方便。<br>– json数据交互思路<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E6%A6%82%E8%BF%B0.png" alt="image"></p><h3 id="json-数据交互步骤"><a href="#json-数据交互步骤" class="headerlink" title="json 数据交互步骤"></a>json 数据交互步骤</h3><p>– 导入jar包<br>– 配置json转换器<br>– 编写页面代码<br>– 编写controller代码  </p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>– 导入jar包<br>– 导入jquery文件<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-jar%E5%8C%85.png" alt="image"></p><h3 id="配置json转换器"><a href="#配置json转换器" class="headerlink" title="配置json转换器"></a>配置json转换器</h3><p><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E9%85%8D%E7%BD%AEjson%E8%BD%AC%E6%8D%A2%E5%99%A8.png" alt="image"></p><font color="red">如果使用<mvc:annotation-driven> 则不用定义上边的内容。<br></mvc:annotation-driven></font><h3 id="输入json串，输出是json串"><a href="#输入json串，输出是json串" class="headerlink" title="输入json串，输出是json串"></a>输入json串，输出是json串</h3><p>– jsp 页面<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-%E9%85%8D%E7%BD%AEjson%E8%BD%AC%E6%8D%A2%E5%99%A8.png" alt="image"></p><h3 id="输入json串，输出是json串-1"><a href="#输入json串，输出是json串-1" class="headerlink" title="输入json串，输出是json串"></a>输入json串，输出是json串</h3><p>– controller<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-controller.png" alt="image"></p><h3 id="输入key-value，输出是json串"><a href="#输入key-value，输出是json串" class="headerlink" title="输入key/value，输出是json串"></a>输入key/value，输出是json串</h3><p>– jsp 页面<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-jsp%E8%BE%93%E5%85%A5.png" alt="image"></p><h3 id="输入key-value，输出是json串-1"><a href="#输入key-value，输出是json串-1" class="headerlink" title="输入key/value，输出是json串"></a>输入key/value，输出是json串</h3><p>– controller<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/json%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92-controller%E8%BE%93%E5%85%A5.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h2&gt;&lt;p&gt;– 导入jar包&lt;br&gt;– 创建虚拟目录&lt;br&gt;– 配置解析器&lt;br&gt;– 编写controller代码&lt;br&gt;– 编写页面代码&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第5章 数据校验</title>
    <link href="http://www.normantriste.top/2017/11/09/%E7%AC%AC5%E7%AB%A0-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <id>http://www.normantriste.top/2017/11/09/第5章-数据校验/</id>
    <published>2017-11-09T00:50:00.000Z</published>
    <updated>2017-11-09T00:52:00.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据校验概述"><a href="#数据校验概述" class="headerlink" title="数据校验概述"></a>数据校验概述</h2><p>• 项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。<br><a id="more"></a><br>• 服务端校验：<br>– 控制层conroller：校验页面请求的参数的合法性。在服务端控制层conroller校验，不区分客户端类型（浏览器、手机客户端、远程调用）<br>– 业务层service（使用较多）：主要校验关键业务参数，仅限于service接口中使用的参数。<br>– 持久层dao：一般是不校验的。  </p><p>• springmvc使用hibernate的校验框架validation<br>• 校验思路：<br>– 页面提交请求的参数，请求到controller方法中，使用validation进行校验。<br>– 如果校验出错，将错误信息展示到页面。  </p><h2 id="数据校验步骤"><a href="#数据校验步骤" class="headerlink" title="数据校验步骤"></a>数据校验步骤</h2><p>• springmvc数据校验步骤<br>– 导入校验jar文件<br>– 配置校验器<br>– 校验器注入到处理器适配器中<br>– 添加校验规则<br>– 错误信息文件<br>– 捕获错误信息<br>– 显示错误信息  </p><h3 id="导入校验jar文件"><a href="#导入校验jar文件" class="headerlink" title="导入校验jar文件"></a>导入校验jar文件</h3><p>– hibernate的校验框架validation所需要jar包<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E5%AF%BC%E5%85%A5jar.png" alt="image"></p><h3 id="配置校验器"><a href="#配置校验器" class="headerlink" title="配置校验器"></a>配置校验器</h3><p>– 在springmvc配置文件中配置<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E9%85%8D%E7%BD%AE%E6%A0%A1%E9%AA%8C%E5%99%A8.png" alt="image"></p><h3 id="校验器注入到处理器适配器中"><a href="#校验器注入到处理器适配器中" class="headerlink" title="校验器注入到处理器适配器中"></a>校验器注入到处理器适配器中</h3><p>– 在springmvc配置文件中配置<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E9%85%8D%E7%BD%AE%E6%A0%A1%E9%AA%8C%E5%99%A82.png" alt="image"></p><h3 id="pojo中添加校验规则"><a href="#pojo中添加校验规则" class="headerlink" title="pojo中添加校验规则"></a>pojo中添加校验规则</h3><p>在ItemsCustom.java中添加<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_pojo.png" alt="image"></p><h3 id="错误信息文件"><a href="#错误信息文件" class="headerlink" title="错误信息文件"></a>错误信息文件</h3><p>– 在CustomValidationMessages.properties配置校验错误信息<br>– 把配置文件放到类路径中<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%E6%96%87%E4%BB%B6.png" alt="image"></p><h3 id="捕获错误信息"><a href="#捕获错误信息" class="headerlink" title="捕获错误信息"></a>捕获错误信息</h3><p>– 在controller方法中捕获<br>– 添加@Validated表示在对items参数绑定时进行校验，校验信息写入BindingResult中，在要校验的pojo后边添加BingdingResult，一个BindingResult对应一个pojo，且BingdingResult放在pojo的后边。<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%8D%95%E6%8D%89%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png" alt="image"><br>– 在controller中将错误信息传到页面即可<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%8D%95%E6%8D%89%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF2.png" alt="image"></p><h3 id="显示错误信息"><a href="#显示错误信息" class="headerlink" title="显示错误信息"></a>显示错误信息</h3><p>– 在jsp页面中将错误信息展示<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png" alt="image"></p><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p>• 在pojo中定义校验规则，而pojo是被多个controller所共用，当不同的controller方法对同一个pojo进行校验，但是每个controller方法需要不同的校验。<br>• 解决方法：<br>– 定义多个校验分组（其实是一个java接口），分组中定义<br>有哪些规则<br>– 每个controller方法使用不同的校验分组  </p><h3 id="定义校验分组"><a href="#定义校验分组" class="headerlink" title="定义校验分组"></a>定义校验分组</h3><p>– 分组就是一个标识，这里定义一个接口<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C1.png" alt="image"></p><h3 id="在校验规则中添加分组"><a href="#在校验规则中添加分组" class="headerlink" title="在校验规则中添加分组"></a>在校验规则中添加分组</h3><p>– 指定分组ValidGroup1，表示此@Size校验只适用ValidGroup1校验<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C2.png" alt="image"></p><h3 id="在controller方法中使用指定分组的校验"><a href="#在controller方法中使用指定分组的校验" class="headerlink" title="在controller方法中使用指定分组的校验"></a>在controller方法中使用指定分组的校验</h3><p>在@Validated中添加value={ValidGroup1.class}表示商品修改使用了ValidGroup1分组校验规则可以指定多个分组，中间用逗号分隔<br>@Validated(value={ValidGroup1.class，ValidGroup2.class })<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C3.png" alt="image"></p><h2 id="校验注解"><a href="#校验注解" class="headerlink" title="校验注解"></a>校验注解</h2><p>•@Null 被注释的元素必须为 null<br>•@NotNull 被注释的元素必须不为 null<br>•@AssertTrue 被注释的元素必须为 true<br>•@AssertFalse 被注释的元素必须为 false<br>•@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小<br>值<br>•@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大<br>值<br>•@DecimalMin(value)   被注释的元素必须是一个数字，其值必须大于等于指定的最小值<br>•@DecimalMax(value)   被注释的元素必须是一个数字，其值必须小于等于指定的最大值<br>•@Size(max=, min=) 被注释的元素的大小必须在指定的范围内<br>•@Digits (integer,fraction)被注释的元素必须是一个数字，其值必须在可接受的范围内<br>•@Past 被注释的元素必须是一个过去的日期<br>•@Future 被注释的元素必须是一个将来的日期<br>•@Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式<br>•@NotBlank(message =) 验证字符串非null，且长度必须大于0<br>•@Email 被注释的元素必须是电子邮箱地址<br>•@Length(min=,max=) 被注释的字符串的大小必须在指定的范围内<br>•@NotEmpty 被注释的字符串的必须非空<br>•@Range(min=,max=,message=) 被注释的元素必须在合适的范围内  </p><h2 id="数据回显"><a href="#数据回显" class="headerlink" title="数据回显"></a>数据回显</h2><p>– 表单提交失败需要再回到表单页面重新填写，原来提交的数据需要重新在页面上显示。<br>– 简单数据类型<br>– pojo类型  </p><h3 id="简单数据类型"><a href="#简单数据类型" class="headerlink" title="简单数据类型"></a>简单数据类型</h3><p>– 对于简单数据类型，如：Integer、String、Float等，使用Model将传入的参数再放到request域实现显示。<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE1.png" alt="image"></p><h3 id="pojo数据类型"><a href="#pojo数据类型" class="headerlink" title="pojo数据类型"></a>pojo数据类型</h3><p>– springmvc默认支持pojo数据回显<br>– springmvc自动将形参中的pojo重新放回request域中，request的key为pojo的类名（首字母小写）<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE2.png" alt="image"><br>springmvc自动将itemsCustom放回request，相当于调用下边的代码：<br>model.addAttribute(“itemsCustom”, itemsCustom);  </p><p>– 如果key不是pojo的类名(首字母小写)，可以使用@ModelAttribute完成数据回显。<br>• @ModelAttribute作用如下：<br>– 如果key不是pojo的类名(首字母小写)，可以使用@ModelAttribute完成数据回显。<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE3.png" alt="image"><br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE4.png" alt="image"></p><p>– 使用最简单方法使用model，可以不用@ModelAttribute<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C_%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE5.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据校验概述&quot;&gt;&lt;a href=&quot;#数据校验概述&quot; class=&quot;headerlink&quot; title=&quot;数据校验概述&quot;&gt;&lt;/a&gt;数据校验概述&lt;/h2&gt;&lt;p&gt;• 项目中，通常使用较多是前端的校验，比如页面中js校验。对于安全要求较高点建议在服务端进行校验。&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第4章 参数绑定</title>
    <link href="http://www.normantriste.top/2017/11/07/%E7%AC%AC4%E7%AB%A0-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/"/>
    <id>http://www.normantriste.top/2017/11/07/第4章-参数绑定/</id>
    <published>2017-11-07T04:11:00.000Z</published>
    <updated>2017-11-07T06:38:21.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参数绑定过程"><a href="#参数绑定过程" class="headerlink" title="参数绑定过程"></a>参数绑定过程</h2><p>• springmvc参数绑定过程<br>– 从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。<br>– springmvc中，接收页面提交的数据是通过方法形参来接收，而不是在controller类定义成员变量接收。<br><a id="more"></a></p><h2 id="默认支持的类型"><a href="#默认支持的类型" class="headerlink" title="默认支持的类型"></a>默认支持的类型</h2><p>• 处理器形参中添加如下类型的参数，处理适配器会默认识别并进行赋值。<br>– HttpServletRequest<br>• 通过request对象获取请求信息<br>– HttpServletResponse<br>• 通过response处理响应信息<br>– HttpSession<br>• 通过session对象得到session中存放的对象<br>– Model/ModelMap<br>• ModelMap是Model接口的实现类，将model数据填充到request域，向页面传递数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">model.addAttribute(<span class="string">"itemsCustom"</span>,itemsCustom);</div><div class="line"><span class="keyword">return</span> <span class="string">"/items/editItems"</span>;</div></pre></td></tr></table></figure></p><h2 id="简单类型绑定"><a href="#简单类型绑定" class="headerlink" title="简单类型绑定"></a>简单类型绑定</h2><p>• 简单类型<br>– 支持整型、字符串、单精度/双精度、布尔型<br>– 当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItem</span><span class="params">(Model model,Integer id)</span> <span class="keyword">throws</span> Excception</span>&#123;</div><div class="line">    <span class="comment">//处理器方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">editItem</span><span class="params">(Model model,Integer id,Boolean status)</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function">    <span class="comment">//请求url：</span></span></div><div class="line"><span class="function">    <span class="comment">//Http：//localhost:8080/springmvc/item/editItem.action?id=2&amp;status=false</span></span></div><div class="line"><span class="function">    <span class="comment">//说明：对于布尔类型的参数，请求的参数值为true或false。</span></span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure></p><p>– 通过@RequestParam对简单类型的参数进行绑定。<br>– 如果不使用@RequestParam，要求request传入参数名称和controller方法的形参名称一致，方可绑定成功。<br>– 如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。  </p><h3 id="RequestParam的参数"><a href="#RequestParam的参数" class="headerlink" title="@RequestParam的参数"></a>@RequestParam的参数</h3><p>– value：参数名字，即入参的请求参数名字，如<br>&emsp;value=”item_id”表示请求的参数中的名字为item_id的参数的值将传入；<br>– required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报错<br>– defaultValue：默认值，表示如果请求中没有同名参数时的默认值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@RequestParam里边指定request传入参数名称和形参进行绑定。</span></div><div class="line"><span class="comment">//通过required属性指定参数是否必须要传入</span></div><div class="line"><span class="comment">//通过defaultValue可以设置默认值，如果id参数没有传入，将默认值和形参绑定</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItem</span><span class="params">(Model model,HttpServletRequest request,</span></span></div><div class="line"><span class="function"><span class="params">        @RequestParam(value=<span class="string">"id"</span>,defaultValue=<span class="string">"2"</span>)</span>Integer idd) <span class="keyword">throws</span> Excception</span>&#123;&#125;</div></pre></td></tr></table></figure><h2 id="POJO类型绑定"><a href="#POJO类型绑定" class="headerlink" title="POJO类型绑定"></a>POJO类型绑定</h2><h3 id="简单POJO绑定"><a href="#简单POJO绑定" class="headerlink" title="简单POJO绑定"></a>简单POJO绑定</h3><p>– 将pojo对象中的属性名与传递进来的属性名对应<br>– 如果传进来的参数名称和对象中的属性名称一致，则将参数值设置在pojo对象中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItemsSubmit"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemSumbit</span><span class="params">(HttpServletRequest request,Integer id,ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    itemsService.updateItems(id,itemsCustom);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="包装POJO绑定"><a href="#包装POJO绑定" class="headerlink" title="包装POJO绑定"></a>包装POJO绑定</h3><p>– 将pojo对象作为一个包装对象的属性，controller方法中以该包装对象作为形参。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsQueryVo</span></span>&#123;</div><div class="line">    <span class="comment">//商品信息</span></div><div class="line">    <span class="keyword">private</span> Items items;</div><div class="line">    </div><div class="line">    <span class="comment">//为了系统可扩展性，对原始生成的po进行扩展</span></div><div class="line">    <span class="keyword">private</span> ItemsCustom itemsCustom;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>商品名称:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"itemsCustom.name"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"查询"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">(HttpServletRequest req,ItemsQueryVo itemsQueryVo)</span></span>&#123;</div><div class="line">    <span class="comment">//调用service查找数据库，查询商品列表</span></div><div class="line">    List&lt;ItemsCuston&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;ItemsCustom&gt;()</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="自定义参数绑定"><a href="#自定义参数绑定" class="headerlink" title="自定义参数绑定"></a>自定义参数绑定</h3><p>• 根据业务需求使用自定义参数绑定。<br>• 需要向处理器适配器中注入自定义的参数绑定组件。<br>• 对于controller形参中pojo对象，如果属性中有日期类型，需要自定义参数绑定。<br>–将请求日期数据串转成日期类型，要转换的日期类型和pojo中日期属性的类型保持一致。  </p><p>• 自定义参数绑定，将日期串转成java.util.Date类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Items</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> Float price;</div><div class="line">    <span class="keyword">private</span> String pic;</div><div class="line">    <span class="comment">//时间</span></div><div class="line">    <span class="keyword">private</span> Date createtime;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>• 自定义Converter，实现Converter接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springMVC.p24_1; </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</div><div class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyy-MM-dd"</span>);</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String arg0)</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="keyword">if</span>(arg0==<span class="keyword">null</span>||arg0.equals(<span class="string">""</span>)) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">Date d =sdf.parse(arg0);</div><div class="line"><span class="keyword">return</span> d;</div><div class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</div><div class="line"></div><div class="line">e.printStackTrace();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">(Date date)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(date==<span class="keyword">null</span>||date.equals(<span class="string">""</span>)) &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> sdf.format(date);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="•-配置方式"><a href="#•-配置方式" class="headerlink" title="• 配置方式"></a>• 配置方式</h3><p>– 需要向处理器适配器中注入自定义的参数绑定组件。  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"converterService"</span> <span class="attr">validator</span>=<span class="string">"validator"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 自定义参数绑定 --&gt;</span></div><div class="line"><span class="comment">&lt;!--加载自定义绑定组件  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"converterService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.</span></span></div><div class="line"><span class="tag"><span class="string">                                FormattingConversionServiceFactoryBean"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"springMVC.p24_1.DateConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="集合类绑定"><a href="#集合类绑定" class="headerlink" title="集合类绑定"></a>集合类绑定</h3><p>• 集合类<br>– 支持字符串数组、List、Map<br>• 例如<br>– 批量删除<br>– 页面选中多个checkbox向controller方法传递<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%91%E5%AE%9A1.png" alt="Markdown"><br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%91%E5%AE%9A2.png" alt="Markdown"></p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>– List中存放对象，并将定义的List放在包装类中，controller方法中使用包装对象接收。<br>• 例如<br>– 批量修改商品<br><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%91%E5%AE%9A3.png" alt="Markdown"></p><p><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%91%E5%AE%9A4.png" alt="Markdown"></p><p><img src="http://normantriste.oss-cn-shenzhen.aliyuncs.com/springMVC/%E9%9B%86%E5%90%88%E7%B1%BB%E7%BB%91%E5%AE%9A5.png" alt="Markdown"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;参数绑定过程&quot;&gt;&lt;a href=&quot;#参数绑定过程&quot; class=&quot;headerlink&quot; title=&quot;参数绑定过程&quot;&gt;&lt;/a&gt;参数绑定过程&lt;/h2&gt;&lt;p&gt;• springmvc参数绑定过程&lt;br&gt;– 从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。&lt;br&gt;– springmvc中，接收页面提交的数据是通过方法形参来接收，而不是在controller类定义成员变量接收。&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第3章 映射请求和返回值</title>
    <link href="http://www.normantriste.top/2017/11/07/%E7%AC%AC3%E7%AB%A0-%E6%98%A0%E5%B0%84%E8%AF%B7%E6%B1%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC/"/>
    <id>http://www.normantriste.top/2017/11/07/第3章-映射请求和返回值/</id>
    <published>2017-11-07T04:11:00.000Z</published>
    <updated>2017-11-07T04:11:48.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RequestMapping映射请求"><a href="#RequestMapping映射请求" class="headerlink" title="@RequestMapping映射请求"></a>@RequestMapping映射请求</h2><p>• Spring MVC 使用@RequestMapping注解为控制器指定可以处理哪些 URL 请求<br>• 在控制器的类定义及方法定义处都可标注<br>– 类定义处：提供初步的请求映射信息。相对于WEB应用的根目录<br>– 方法处：提供进一步的细分映射信息。相对于类定义处的URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录<br>• DispatcherServlet 截获请求后，就通过控制器上@RequestMapping提供的映射信息确定请求所对应的处理方法。<br><a id="more"></a></p><h3 id="RequestMapping修饰类"><a href="#RequestMapping修饰类" class="headerlink" title="@RequestMapping修饰类"></a>@RequestMapping修饰类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/items"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController</span></span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="RequestMapping修饰方法"><a href="#RequestMapping修饰方法" class="headerlink" title="@RequestMapping修饰方法"></a>@RequestMapping修饰方法</h3><ul><li>@RequestMapping 除了可以使用请求URL映射请求外，还可以使用请求方法、请求参数及请求头映射请求</li><li>@RequestMapping 的value、method、params及heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。</li></ul><h4 id="限制http请求方法，可以post和get"><a href="#限制http请求方法，可以post和get" class="headerlink" title="限制http请求方法，可以post和get"></a>限制http请求方法，可以post和get</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//限制http请求方法，可以post和get</span></div><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/editItems"</span>,method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)</div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">editItems</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">    ItemsCustom itemsCustom itemsService.findItemsById(<span class="number">1</span>);</div><div class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</div><div class="line">    mav.addObject(<span class="string">"itemsCustom"</span>,itemsCustom);</div><div class="line">    mav.setViewName(<span class="string">"/items/editItems"</span>);</div><div class="line">    <span class="keyword">return</span> mav;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="限制带参数"><a href="#限制带参数" class="headerlink" title="限制带参数"></a>限制带参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/delete"</span>,method=RequestMothod.POST,params=<span class="string">"userId"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"user/test1"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/show"</span>,headers=<span class="string">"conntentType="</span>text<span class="comment">/*")</span></div><div class="line"><span class="comment">public String test2()&#123;</span></div><div class="line"><span class="comment">    //...</span></div><div class="line"><span class="comment">    return "user/test2";</span></div><div class="line"><span class="comment">&#125;</span></div></pre></td></tr></table></figure><h2 id="controller方法的返回值"><a href="#controller方法的返回值" class="headerlink" title="controller方法的返回值"></a>controller方法的返回值</h2><p>• controller方法的返回值<br>– 返回ModelAndView<br>– 返回字符串<br>– 返回void  </p><h3 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h3><p>– controller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。  </p><h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>– 表示返回逻辑视图名<br>– redirect重定向<br>&emsp;redirect重定向特点：浏览器地址栏中的url会变化。修改提交的request数据无传到重定向的地址。因为重定向后重新进行request（request无法共享）<br>– forward页面转发<br>&emsp;通过forward进行页面转发，浏览器地址栏url不变，request可以共享。<br>– 返回void<br>&emsp;在controller方法形参上可以定义request和response，使用request或response指定响应结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">– 使用request转向页面，如下：  </div><div class="line">• request.getRequestDispatcher(<span class="string">"页面路径"</span>).forward(request, response);  </div><div class="line">– 可以通过response页面重定向：</div><div class="line">• response.sendRedirect(<span class="string">"url"</span>)</div><div class="line">– 可以通过response指定响应结果，例如响应json数据如下：</div><div class="line">• response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line">• response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</div><div class="line">• response.getWriter().write(<span class="string">"json串"</span>);</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回逻辑视图名：真正视图(jsp路径)=前缀+逻辑视图名+后缀</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getAllEmps"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAllEmps</span><span class="params">(Model nodel)</span></span>&#123;</div><div class="line">    Lis&lt;Emp&gt; empList = empService.getAllEmps();</div><div class="line">    <span class="comment">//通过形参中的model将model数据传到页面</span></div><div class="line">    <span class="comment">//相当于modelAndView.addObject方法</span></div><div class="line">    model.addAttribute(<span class="string">"empList"</span>,emplist);</div><div class="line">    <span class="keyword">return</span> <span class="string">"empQuery"</span>; <span class="comment">//会拼接前后缀</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getAllEmps1"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAllEmps1</span><span class="params">(HttpServletRequest request)</span></span>&#123;</div><div class="line">    Lis&lt;Emp&gt; empList = empService.getAllEmps();</div><div class="line">    reuqest.setAttribute(<span class="string">"empList"</span>,emplist);</div><div class="line">    <span class="keyword">return</span> <span class="string">"empQuery"</span>; <span class="comment">//会拼接前后缀</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//返回字符串：转发forward：</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getAllEmps2"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAllEmps2</span><span class="params">(HttpServletRequest request)</span></span>&#123;</div><div class="line">     Lis&lt;Emp&gt; empList = empService.getAllEmps();</div><div class="line">    reuqest.setAttribute(<span class="string">"empList"</span>,emplist);</div><div class="line">    <span class="keyword">return</span> <span class="string">"forward:empQuery.jsp"</span>; <span class="comment">// 不会拼接前后缀</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//返回字符串：重定向redirect：</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getAllEmps3"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAllEmps3</span><span class="params">(HttpServletRequest request)</span></span>&#123;</div><div class="line">     Lis&lt;Emp&gt; empList = empService.getAllEmps();</div><div class="line">    reuqest.getSession().setAttribute(<span class="string">"empList"</span>,emplist);</div><div class="line">    <span class="keyword">return</span> <span class="string">"redirect:empQuery.jsp"</span>; <span class="comment">// 不会拼接前后缀</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//无返回值：void</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getAllEmps4"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllEmps4</span><span class="params">(HttpServletRequest req，HttpServletResponse resp)</span></span>&#123;</div><div class="line">    <span class="comment">//原生的servlet写法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RequestMapping映射请求&quot;&gt;&lt;a href=&quot;#RequestMapping映射请求&quot; class=&quot;headerlink&quot; title=&quot;@RequestMapping映射请求&quot;&gt;&lt;/a&gt;@RequestMapping映射请求&lt;/h2&gt;&lt;p&gt;• Spring MVC 使用@RequestMapping注解为控制器指定可以处理哪些 URL 请求&lt;br&gt;• 在控制器的类定义及方法定义处都可标注&lt;br&gt;– 类定义处：提供初步的请求映射信息。相对于WEB应用的根目录&lt;br&gt;– 方法处：提供进一步的细分映射信息。相对于类定义处的URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录&lt;br&gt;• DispatcherServlet 截获请求后，就通过控制器上@RequestMapping提供的映射信息确定请求所对应的处理方法。&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第2章 处理器映射器和适配器</title>
    <link href="http://www.normantriste.top/2017/11/07/%E7%AC%AC2%E7%AB%A0-%E5%A4%84%E7%90%86%E5%99%A8%E6%98%A0%E5%B0%84%E5%99%A8%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://www.normantriste.top/2017/11/07/第2章-处理器映射器和适配器/</id>
    <published>2017-11-07T04:09:00.000Z</published>
    <updated>2017-11-07T04:10:52.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="非注解配置适配器、映射器"><a href="#非注解配置适配器、映射器" class="headerlink" title="非注解配置适配器、映射器"></a>非注解配置适配器、映射器</h2><h3 id="非注解-处理器映射器：根据url请求查找处理器"><a href="#非注解-处理器映射器：根据url请求查找处理器" class="headerlink" title="[非注解]处理器映射器：根据url请求查找处理器"></a>[非注解]处理器映射器：根据url请求查找处理器</h3><a id="more"></a><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--方式一：BenaNameUrlHandlerMapping 根据bean的name属性值匹配URL地址--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!--方式二：SimpleUrlHandlerMapping 根据bean的id属性值匹配URL地址 </span></div><div class="line"><span class="comment">            属于方式一的增强版，与方式一可以共存</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/hello2.action"</span>&gt;</span><span class="tag">&lt;/<span class="name">prop</span>&gt;</span><span class="comment">&lt;!-- key：url地址 value：id属性值--&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 处理器：负责执行后台的代码 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"/hello2.action"</span> <span class="attr">name</span>=<span class="string">"/hello.action"</span> <span class="attr">class</span>=<span class="string">"controller.HelloController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="非注解-处理器适配器-：负责根据指定规则执行处理器"><a href="#非注解-处理器适配器-：负责根据指定规则执行处理器" class="headerlink" title="[非注解]处理器适配器  ：负责根据指定规则执行处理器"></a>[非注解]处理器适配器  ：负责根据指定规则执行处理器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- </span></div><div class="line"><span class="comment">    方式一：SimpleControllerHandlerAdapter:适配执行所有的实现了</span></div><div class="line"><span class="comment">            org.springframework.web.servlet.mvc.Controller接口的类</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- </span></div><div class="line"><span class="comment">    方式二：HttpRequestHandlerAdapter:适配执行所有的实现了org.springframework.web.servlet.mvc.HttpRequestHandler接口的类，与方式一相同</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="注解配置适配器、映射器"><a href="#注解配置适配器、映射器" class="headerlink" title="注解配置适配器、映射器"></a>注解配置适配器、映射器</h2><h3 id="注解配置适配器"><a href="#注解配置适配器" class="headerlink" title="注解配置适配器"></a>注解配置适配器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="注解配置映射器"><a href="#注解配置映射器" class="headerlink" title="注解配置映射器"></a>注解配置映射器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Controller</span> <span class="comment">//表示该类为处理器(控制器)</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>) <span class="comment">//代表方法的访问路径</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">       ModelAndView mav = <span class="keyword">new</span> ModelAndView();</div><div class="line">       mav.setObject(<span class="string">"message"</span>,<span class="string">"hello,注解controller"</span>);</div><div class="line">       mav.setViewName(<span class="string">"/main.jsp"</span>);</div><div class="line">       <span class="keyword">return</span> mav;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="替换以上方式-注解配置适配器和映射器"><a href="#替换以上方式-注解配置适配器和映射器" class="headerlink" title="替换以上方式 注解配置适配器和映射器"></a>替换以上方式 注解配置适配器和映射器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在配置文件上方加入</span></div><div class="line"><span class="comment">     xmlns:mvc="http://www.springframework.org/schema/mvc"</span></div><div class="line"><span class="comment">     在xsi:schemaLocation="http://www.springframework.org/schema/mvc</span></div><div class="line"><span class="comment">                           http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd"</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="批量管理处理器"><a href="#批量管理处理器" class="headerlink" title="批量管理处理器"></a>批量管理处理器</h2><h3 id="批量扫描包中的组件"><a href="#批量扫描包中的组件" class="headerlink" title="批量扫描包中的组件"></a>批量扫描包中的组件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在配置文件上方加入</span></div><div class="line"><span class="comment">     xmlns:context="http://www.springframework.org/schema/context"</span></div><div class="line"><span class="comment">     在xsi:schemaLocation="http://www.springframework.org/schema/context</span></div><div class="line"><span class="comment">                           http://www.springframework.org/schema/context/spring-context-4.1.xsd"</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="comment">&lt;!-- 批量扫描controller包中的组件(类需要用@Controller修饰，可替换以上bean的定义语句)--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="bean批量扫描"><a href="#bean批量扫描" class="headerlink" title="bean批量扫描"></a>bean批量扫描</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 扫描com.xxx包下面的组件，</span></div><div class="line"><span class="comment">@Controller：处理器</span></div><div class="line"><span class="comment">@Service：业务逻辑层</span></div><div class="line"><span class="comment">@Repository（仓库）：数据持久层</span></div><div class="line"><span class="comment">@Component：泛指组件，用于不明确组件的注解</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.xxx"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="视图解析器前后缀配置"><a href="#视图解析器前后缀配置" class="headerlink" title="视图解析器前后缀配置"></a>视图解析器前后缀配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 前缀 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 后缀 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;非注解配置适配器、映射器&quot;&gt;&lt;a href=&quot;#非注解配置适配器、映射器&quot; class=&quot;headerlink&quot; title=&quot;非注解配置适配器、映射器&quot;&gt;&lt;/a&gt;非注解配置适配器、映射器&lt;/h2&gt;&lt;h3 id=&quot;非注解-处理器映射器：根据url请求查找处理器&quot;&gt;&lt;a href=&quot;#非注解-处理器映射器：根据url请求查找处理器&quot; class=&quot;headerlink&quot; title=&quot;[非注解]处理器映射器：根据url请求查找处理器&quot;&gt;&lt;/a&gt;[非注解]处理器映射器：根据url请求查找处理器&lt;/h3&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>第1章 SpringMVC概述</title>
    <link href="http://www.normantriste.top/2017/11/07/%E7%AC%AC1%E7%AB%A0-SpringMVC%E6%A6%82%E8%BF%B0/"/>
    <id>http://www.normantriste.top/2017/11/07/第1章-SpringMVC概述/</id>
    <published>2017-11-07T04:08:00.000Z</published>
    <updated>2017-11-07T04:09:33.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h3><ul><li>springmvc是spring框架的一个模块，springmvc和spring<br>无需通过中间整合层进行整合。</li><li>springmvc是一个基于mvc的web框架。<a id="more"></a><h3 id="MVC在B-S系统下的应用"><a href="#MVC在B-S系统下的应用" class="headerlink" title="MVC在B/S系统下的应用"></a>MVC在B/S系统下的应用</h3><strong>1. 用户发起request请求至控制器(Controller)</strong><br>&emsp;控制接收用户请求的数据，委托给模型进行处理<br><strong>2. 控制器通过模型(Model)处理数据并得到处理结果</strong><br>&emsp;模型通常是指业务逻辑<br><strong>3. 模型处理结果返回给控制器</strong><br><strong>4. 控制器将模型数据在视图(View)中展示</strong><br>&emsp;web中模型无法将数据直接在视图上显示，需要通过控制器完成。如果在C/S应用中模型是可以将数据在视图中展示的。<br><strong>5. 控制器将视图response响应给用户</strong><br>&emsp;通过视图展示给用户要的数据或处理结果。</li></ul><h3 id="SpringMVC框架"><a href="#SpringMVC框架" class="headerlink" title="SpringMVC框架"></a>SpringMVC框架</h3><ul><li>Spring 为展现层提供的基于 MVC 设计理念的优秀的Web<br>框架，是目前最主流的 MVC 框架之一</li><li>Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架</li><li>Spring MVC 通过一套 MVC 注解,让POJO成为处理请求<br>的控制器，而无须实现任何接口</li><li>支持 REST 风格的 URL 请求</li><li>采用了松散耦合可插拔组件结构，比其他 MVC </li></ul><ol><li>第一步：发起请求到前端控制器(DispatcherServlet)</li><li>第二步：前端控制器请求HandlerMapping查找 Handler<br>• 可以根据xml配置、注解进行查找</li><li>第三步：处理器映射器HandlerMapping向前端控制器返回Handler</li><li>第四步：前端控制器调用处理器适配器去执行Handler</li><li>第五步：处理器适配器去执行Handler</li><li>第六步：Handler执行完成给适配器返回ModelAndView</li><li>第七步：处理器适配器向前端控制器返回ModelAndVie</li><li>第八步：前端控制器请求视图解析器去进行视图解析<br>• 根据逻辑视图名解析成真正的视图(jsp)</li><li>第九步：视图解析器向前端控制器返回View</li><li>第十步：前端控制器进行视图渲染<br>• 视图渲染将模型数据(在ModelAndView对象中)填充到<br>request域</li><li>视图渲染将模型数据(在ModelAndView对象中)填充到request域</li><li>第十一步：前端控制器向用户响应结果</li></ol><h3 id="SpringMVC组件"><a href="#SpringMVC组件" class="headerlink" title="SpringMVC组件"></a>SpringMVC组件</h3><p><strong>– 前端控制器DispatcherServlet(不需要程序员开发)</strong><br>• 作用接收请求，响应结果，相当于转发器，中央处理器<br>• 有了DispatcherServlet减少了其它组件之间的耦合度<br><strong>– 处理器映射器HandlerMapping(不需要程序员开发)</strong><br>• 作用：根据请求的url查找Handler<br><strong>– 处理器适配器HandlerAdapter</strong><br>• 作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler<br><strong>– 处理器Handler(需要程序员开发)</strong><br>• 注意：编写Handler时按照HandlerAdapter的要求去做,这样适配器才可以去正确执行Handler<br><strong>– 视图解析器View resolver(不需要程序员开发)</strong><br>• 作用：进行视图解析，根据逻辑视图名解析成真正的视  图（view）<br><strong>– 视图View(需要程序员开发jsp)</strong><br>• View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p><h3 id="开发步骤："><a href="#开发步骤：" class="headerlink" title="开发步骤："></a>开发步骤：</h3><p>– 创建web工程<br>– 导入 jar 包<br>– 在 web.xml 中配置 DispatcherServlet<br>– 配置处理器适配器<br>– 编写处理请求的处理器<br>– 配置处理器映射器<br>– 编写视图<br>– 配置视图解析器<br>– 部署调试   </p><h4 id="在-web-xml-中配置-DispatcherServlet"><a href="#在-web-xml-中配置-DispatcherServlet" class="headerlink" title="在 web.xml 中配置 DispatcherServlet"></a>在 web.xml 中配置 DispatcherServlet</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 前端控制器:负责所有的请求与响应 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">     <span class="comment">&lt;!-- 配置初始化参数--&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span><span class="comment">&lt;!-- 固定的初始化参数名 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!-- 匹配所有以action结尾的路径--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="在classpath下的springmvc-xml中配置处理器适配器"><a href="#在classpath下的springmvc-xml中配置处理器适配器" class="headerlink" title="在classpath下的springmvc.xml中配置处理器适配器"></a>在classpath下的springmvc.xml中配置处理器适配器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> </span></div><div class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></div></pre></td></tr></table></figure><h4 id="编写处理器Handler"><a href="#编写处理器Handler" class="headerlink" title="编写处理器Handler"></a>编写处理器Handler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需要实现 controller接口，才能由</span></div><div class="line"><span class="comment">// org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter适配器执行。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> <span class="keyword">implements</span> <span class="title">Controller</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request,</span></span></div><div class="line"><span class="function"><span class="params">    HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</div><div class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"hello springmvc"</span>);</div><div class="line">        mav.setViewName(<span class="string">"hello.jsp"</span>);</div><div class="line">        <span class="keyword">return</span> mav;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="在classpath下的springmvc-xml中配置处理器映射器"><a href="#在classpath下的springmvc-xml中配置处理器映射器" class="headerlink" title="在classpath下的springmvc.xml中配置处理器映射器"></a>在classpath下的springmvc.xml中配置处理器映射器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span></span></div><div class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/hello.action"</span> <span class="attr">class</span>=<span class="string">"com.ttc.controller.HelloController"</span> &gt;</span></div></pre></td></tr></table></figure><h4 id="在classpath下的springmvc-xml中配置视图解析器"><a href="#在classpath下的springmvc-xml中配置视图解析器" class="headerlink" title="在classpath下的springmvc.xml中配置视图解析器"></a>在classpath下的springmvc.xml中配置视图解析器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span></span></div><div class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>/&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是SpringMVC&quot;&gt;&lt;a href=&quot;#什么是SpringMVC&quot; class=&quot;headerlink&quot; title=&quot;什么是SpringMVC&quot;&gt;&lt;/a&gt;什么是SpringMVC&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;springmvc是spring框架的一个模块，springmvc和spring&lt;br&gt;无需通过中间整合层进行整合。&lt;/li&gt;
&lt;li&gt;springmvc是一个基于mvc的web框架。
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
      <category term="SpringMVC" scheme="http://www.normantriste.top/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存数据库(二)</title>
    <link href="http://www.normantriste.top/2017/11/02/Redis%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8C/"/>
    <id>http://www.normantriste.top/2017/11/02/Redis内存数据库-二/</id>
    <published>2017-11-02T11:58:00.000Z</published>
    <updated>2017-11-02T12:19:42.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><p>• 通过主从复制可以允许多个 slave server 拥有和master server相同的数据库副本<br>• 读写分离<br>• 提高系统的伸缩性<br>• 防止单点故障<br><a id="more"></a><br>• redis 主从复制特点<br>– master 可以拥有多个 slave<br>– 多个 slave 可以连接同一个master外，还可以连接到其他slave<br>– 主从复制不会阻塞master，在同步数据时，master可以继续处理 client 请求<br>– 提高系统的伸缩性  </p><h3 id="Redis主从复制原理"><a href="#Redis主从复制原理" class="headerlink" title="Redis主从复制原理"></a>Redis主从复制原理</h3><p>• 当一个从数据库启动时，会向主数据库发送SYNC命令，主数据库收到命令后会开始在后台保存快照（即RDB持久化过程），并将保存快照期间接收到的命令缓存起来。<br>• 当快照完成后，Redis会将快照文件和缓存的命令发给从数据库，从数据库收到数据后，会载入快照文件并执行缓存的命令。<br>以上过程称为复制初始化。<br>• 复制初始化结束后，主数据库每收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致，这一过程称为复制同步阶段。  </p><p>1、复制产生新的主服务器配置文件<br>    redis.windows_M.conf</p><p>a、修改端口号 为6000<br>b、修改密码为： 123456<br>注：仅修改两项</p><p>2、复制产生新的从服务器配置文件<br>    redis.windows_S1.conf</p><p>a、修改端口号 为6001<br>b、修改密码为： 123456（建议与主服务器密码一样）<br>c、修改并设置主服务器地址与端口号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;(去掉前面的#号)</div><div class="line">&lt;masterip&gt;修改为 主服务器的Ip地址</div><div class="line">&lt;masterport&gt;修改为 主服务器端口</div><div class="line"></div><div class="line">修改后：</div><div class="line">slaveof 127.0.0.1 6000</div></pre></td></tr></table></figure></p><p>d、修改连接主服务器的密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># masterauth &lt;master-password&gt;(去掉前面的#号)</div><div class="line">修改后：</div><div class="line">masterauth 123456</div></pre></td></tr></table></figure></p><p>3、用户客户端连接–主服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli -p 6000</div><div class="line">auth 123456</div></pre></td></tr></table></figure></p><p>4、用客户端连接–从服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli -p 6001</div><div class="line">auth 123456</div></pre></td></tr></table></figure></p><h3 id="Java-使用-Redis–Java连接到Redis服务器"><a href="#Java-使用-Redis–Java连接到Redis服务器" class="headerlink" title="Java 使用 Redis–Java连接到Redis服务器"></a>Java 使用 Redis–Java连接到Redis服务器</h3><p>在java中使用Redis，需要引入Redis驱动–jedis-2.1.0.jar<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">commons-pool-1.6.jar  </div><div class="line">jedis-2.1.0.jar</div></pre></td></tr></table></figure></p><p>RedisUtil.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> redisTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</div><div class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</div><div class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</div><div class="line">String addr = <span class="string">"localhost"</span>;<span class="comment">//主机地址或IP地址</span></div><div class="line"><span class="keyword">int</span> port = <span class="number">6379</span>;<span class="comment">//端口号</span></div><div class="line">String auth= <span class="string">"123456"</span>;<span class="comment">//密码</span></div><div class="line"><span class="comment">//最大连接数量</span></div><div class="line"><span class="keyword">int</span> max_active = <span class="number">100</span>;</div><div class="line"><span class="comment">//最大空闲数量</span></div><div class="line"><span class="keyword">int</span> max_idle = <span class="number">100</span>;</div><div class="line"><span class="comment">//等待时间,获取可用连接最大等待时间 ,默认为-1表示用不超时</span></div><div class="line"><span class="keyword">int</span> max_wait = <span class="number">2000</span>;</div><div class="line"><span class="comment">//设置超时</span></div><div class="line"><span class="keyword">int</span> timeout = <span class="number">5000</span>;</div><div class="line"></div><div class="line">JedisPool jedispool;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisUtil</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="comment">// 连接池</span></div><div class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</div><div class="line">config.setMaxActive(max_active);</div><div class="line">config.setMaxIdle(max_idle);</div><div class="line">config.setMaxWait(max_wait);</div><div class="line"></div><div class="line">config.setTestOnBorrow(<span class="keyword">true</span>);<span class="comment">//创建实例验证，保证创建出来的实例是可用的</span></div><div class="line"></div><div class="line">jedispool = <span class="keyword">new</span> JedisPool(config, addr,port,timeout,auth);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(jedispool!=<span class="keyword">null</span>) &#123;</div><div class="line"><span class="keyword">return</span> jedispool.getResource();</div><div class="line">&#125;<span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnResource</span><span class="params">(Jedis jedis)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span>(jedis!=<span class="keyword">null</span>) &#123;</div><div class="line">jedispool.returnResource(jedis);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试 Test.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> redisTest;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Set;</div><div class="line"></div><div class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">RedisUtil ru = <span class="keyword">new</span> RedisUtil();</div><div class="line">Jedis jedis = ru.getJedis();</div><div class="line"></div><div class="line">testString(jedis);</div><div class="line">testMap(jedis);</div><div class="line">testList(jedis);</div><div class="line">testSet(jedis);</div><div class="line">ru.returnResource(jedis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">(Jedis jedis)</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"-------------String-------------"</span>);</div><div class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"zs"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"name="</span>+jedis.get(<span class="string">"name"</span>));</div><div class="line"></div><div class="line">jedis.append(<span class="string">"name"</span>, <span class="string">" hello !"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"name="</span>+jedis.get(<span class="string">"name"</span>));</div><div class="line"></div><div class="line">jedis.del(<span class="string">"name"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"name="</span>+jedis.get(<span class="string">"name"</span>));</div><div class="line"></div><div class="line">jedis.mset(<span class="string">"name"</span>,<span class="string">"张三"</span>,<span class="string">"age"</span>,<span class="string">"20"</span>,<span class="string">"email"</span>,<span class="string">"xxx@qq.com"</span>);</div><div class="line">jedis.incr(<span class="string">"age"</span>);</div><div class="line"></div><div class="line">System.out.println(jedis.get(<span class="string">"name"</span>)+<span class="string">"  "</span>+jedis.get(<span class="string">"age"</span>));</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">(Jedis j)</span> </span>&#123;</div><div class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span>  HashMap&lt;&gt;();</div><div class="line">map.put(<span class="string">"name"</span>, <span class="string">"zs"</span>);</div><div class="line">map.put(<span class="string">"age"</span>, <span class="string">"20"</span>);</div><div class="line">map.put(<span class="string">"email"</span>, <span class="string">"zs@163.com"</span>);</div><div class="line"></div><div class="line">j.hmset(<span class="string">"stu"</span>, map);<span class="comment">//将学生信息的map 放入到redis服务器中</span></div><div class="line"></div><div class="line">List&lt;String&gt; list = j.hmget(<span class="string">"stu"</span>,<span class="string">"name"</span>, <span class="string">"age"</span>,<span class="string">"email"</span> );</div><div class="line">System.out.println(<span class="string">"-------------Map----------------"</span>);</div><div class="line">System.out.println(list);</div><div class="line"></div><div class="line"><span class="comment">//j.hget("stu", "name");</span></div><div class="line"><span class="comment">//j.hlen("stu");</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//j.exists("stu");</span></div><div class="line">Set set = j.hkeys(<span class="string">"stu"</span>);</div><div class="line"><span class="comment">//j.hvals(key);</span></div><div class="line"></div><div class="line">Iterator ite = set.iterator();</div><div class="line"><span class="keyword">while</span>(ite.hasNext()) &#123;</div><div class="line">System.out.println(ite.next());</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">(Jedis j)</span> </span>&#123;</div><div class="line">j.del(<span class="string">"java"</span>);<span class="comment">//删除</span></div><div class="line">j.lpush(<span class="string">"java"</span>, <span class="string">"spring"</span>);</div><div class="line">j.lpush(<span class="string">"java"</span>, <span class="string">"springMvc"</span>);</div><div class="line">j.lpush(<span class="string">"java"</span>, <span class="string">"mybatis"</span>);</div><div class="line">j.lpush(<span class="string">"java"</span>, <span class="string">"java基础"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"-------------list---------------"</span>);</div><div class="line">System.out.println(<span class="string">"长度："</span>+j.llen(<span class="string">"java"</span>));</div><div class="line"></div><div class="line">System.out.println(<span class="string">"java:0"</span>+j.lrange(<span class="string">"java"</span>, <span class="number">0</span>, -<span class="number">1</span>));<span class="comment">//列出所有</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">(Jedis j)</span> </span>&#123;</div><div class="line"></div><div class="line">j.sadd(<span class="string">"user"</span>, <span class="string">"a1"</span>);</div><div class="line">j.sadd(<span class="string">"user"</span>, <span class="string">"a2"</span>);</div><div class="line">j.sadd(<span class="string">"user"</span>, <span class="string">"a3"</span>);</div><div class="line">j.sadd(<span class="string">"user"</span>, <span class="string">"a4"</span>);</div><div class="line">j.sadd(<span class="string">"user"</span>, <span class="string">"a5"</span>);</div><div class="line">j.sadd(<span class="string">"user"</span>, <span class="string">"a6"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"-------------set----------------"</span>);</div><div class="line">System.out.println(<span class="string">"user:"</span>+j.smembers(<span class="string">"user"</span>));</div><div class="line">j.srem(<span class="string">"user"</span>, <span class="string">"a5"</span>);<span class="comment">//删除元素</span></div><div class="line">System.out.println(<span class="string">"user:"</span>+j.smembers(<span class="string">"user"</span>)+<span class="string">"删除了a5"</span>);</div><div class="line"></div><div class="line">System.out.println(<span class="string">"获取集合元素个数："</span>+j.scard(<span class="string">"user"</span>));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">运行结果：</div><div class="line">-------------String-------------</div><div class="line">name=zs</div><div class="line">name=zs hello !</div><div class="line">name=<span class="keyword">null</span></div><div class="line">张三  <span class="number">21</span></div><div class="line">-------------Map----------------</div><div class="line">[zs, <span class="number">20</span>, zs@<span class="number">163</span>.com]</div><div class="line">name</div><div class="line">age</div><div class="line">email</div><div class="line">-------------list---------------</div><div class="line">长度：<span class="number">4</span></div><div class="line">java:<span class="number">0</span>[java基础, mybatis, springMvc, spring]</div><div class="line">-------------set----------------</div><div class="line">user:[a1, a2, a3, a4, a5, a6]</div><div class="line">user:[a1, a2, a3, a4, a6]删除了a5</div><div class="line">获取集合元素个数：<span class="number">5</span></div></pre></td></tr></table></figure></p><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><p>• Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。<br>• Redis事务的实现需要用到MULTI和EXEC两个命令，事务开始的时候先向Redis服务器发送MULTI命令，然后依次发送需要在本次事务中处理的命令，最后再发送EXEC命令表示事务命令结束。<br>• 事务控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">multi  </div><div class="line">set age 10  </div><div class="line">set age 20  </div><div class="line">exec  </div><div class="line">get age</div></pre></td></tr></table></figure></p><p>• 取消一个事务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">multi</div><div class="line">set age 10</div><div class="line">set age 20</div><div class="line">discard</div><div class="line">get age</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Jedis jedis = RedisUtil.getJedis();</div><div class="line">Transaction tx = jedis.multi();</div><div class="line">tx.set(<span class="string">"name"</span>, <span class="string">"ljs"</span>);</div><div class="line">tx.set(<span class="string">"name"</span>, <span class="string">"ljs1"</span>);</div><div class="line">tx.exec();</div><div class="line">System.out.println(jedis.get(<span class="string">"name"</span>));</div><div class="line">RedisUtil.returnResource(jedis);</div></pre></td></tr></table></figure><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>• redis 是一个支持持久化的内存数据库，redis经常将内存中的数据同步到磁盘来保证持久化。<br>• redis 支持两种持久化方式<br>– Snapshotting（快照）默认方式<br>– Append-only file（aof）方式  </p><h4 id="一、快照"><a href="#一、快照" class="headerlink" title="一、快照"></a>一、快照</h4><p>• 快照是默认的持久化方式,这种方式就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。<br>• Snapshotting机制运行原理<br>– redis 调用 fork产生子进程<br>– 父进程继续处理client请求，子进程负责将内存内容写入到临时文件。<br>– 子进程将快照写入临时文件后，用临时文件替换原来的快照文件，然后子进程<br>退出 </p><p>• 设置自动做快照持久化的方式 ,在 n 秒内如果超过 m 个 key被修改就自动做快照.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">save 900 1 </div><div class="line">#900 秒内如果超过 1 个 key被修改，则发起快照保存</div><div class="line">save 300 10 </div><div class="line">#300 秒内如果超过10个key被修改，则发起快照保存</div><div class="line">save 60 10000</div><div class="line">• dbfilename</div><div class="line">快照备份文件的文件名</div><div class="line">• dir</div><div class="line">数据库快照备份的文件放置的路径</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dir 快照目录  </div><div class="line">dbfilename dump.rdb  //快照文件名  </div><div class="line">stop-writes-on-bgsave-error yes //出错后是否暂停写操作  </div><div class="line">rdbcompression yes //是否压缩  </div><div class="line"></div><div class="line">save 秒 次 // 要求同时满足条件</div></pre></td></tr></table></figure><h4 id="二、aof"><a href="#二、aof" class="headerlink" title="二、aof"></a>二、aof</h4><p>• 快照方式是在一定间隔时间做一次的，如果 redis 意外down 掉，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改，可以采用 aof 持久化方式 。<br>• 在使用 aof 持久化方式时,redis以日志形式记录服务器的每一个写操作，默认是 appendonly.aof文件。<br>• 当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">• aof配置</div><div class="line">– appendonly yes</div><div class="line">– appendfsync always</div><div class="line">– appendfsync everysec</div><div class="line">– appendfsync no</div><div class="line">• aof文件体积过大时，系统重启恢复数据非常慢，几十G的数据</div><div class="line">可能要几小时才能加载完，为了压缩 aof 的持久化文件，</div><div class="line">redis 提供了 bgrewriteaof 命令。</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">appendonly no/yes       是否启用  </div><div class="line">appendfsync always      每次修改就同步  </div><div class="line">            everysec    每秒同步一次  </div><div class="line">            no          从不同步</div></pre></td></tr></table></figure><h3 id="snapshotting-与-AOF-对比"><a href="#snapshotting-与-AOF-对比" class="headerlink" title="snapshotting 与 AOF 对比"></a>snapshotting 与 AOF 对比</h3><table style="margin-top:-420px;background:#002b36;"><br>    <tr style="background:#0083a0;"><br>        <th>持久化技术</th><br>        <th>优势</th><br>        <th>欠缺</th><br>    </tr><br>    <tr><br>        <td>snapshotting</td><br>        <td>1、RDB产生的文件小<br><br>2、RDB恢复快，可以快速将RDB文件传输到其他主机做数据恢复<br><br>3、在进行RDB备份时，主进程只需要创建一个子进程，所有的I/O操作都<br>由子进程完成</td><br>        <td>1、不能完全保证数据安全，在两个备份点之间可能发生数<br>据丢失<br><br>2、当数据量很大时，RDB可能会严重影响性能</td><br>    </tr><br>    <tr><br>        <td>snapshotting</td><br>        <td>1、数据备份粒度更小，数据安全性更高。<br>2、AOF只对日志文件进行追加操作，即使掉电，AOF日志仍然可用。</td><br>        <td>1、AOF文件通常比相同数据集的RDB文件大<br><br>2、AOF写日志可能会很慢</td><br>    </tr><br></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis主从复制&quot;&gt;&lt;a href=&quot;#Redis主从复制&quot; class=&quot;headerlink&quot; title=&quot;Redis主从复制&quot;&gt;&lt;/a&gt;Redis主从复制&lt;/h3&gt;&lt;p&gt;• 通过主从复制可以允许多个 slave server 拥有和master server相同的数据库副本&lt;br&gt;• 读写分离&lt;br&gt;• 提高系统的伸缩性&lt;br&gt;• 防止单点故障&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://www.normantriste.top/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://www.normantriste.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis内存数据库(一)</title>
    <link href="http://www.normantriste.top/2017/11/01/Redis%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://www.normantriste.top/2017/11/01/Redis内存数据库/</id>
    <published>2017-11-01T11:36:00.000Z</published>
    <updated>2017-11-01T11:45:28.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><span>&emsp;&emsp;Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。<a id="more"></a><br>&emsp;&emsp;redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set–有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。<br>&emsp;&emsp;Redis 是一个高性能的key-value数据库。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便.<br>&emsp;&emsp;Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</span></p><h4 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a>NoSql</h4><p>Not Only SQL，是非关系型的数据库<br>• 处理超大数据量，TB or PB级别<br>• 高并发（万/s），不注重事务（CAP原则）<br>• 易部署、易扩展、易开发<br>• 便宜    </p><h4 id="Key-Value-Store"><a href="#Key-Value-Store" class="headerlink" title="Key-Value Store"></a>Key-Value Store</h4><p>&emsp;&emsp;Key-Value Store 更加注重对海量数据存取的性能、分布式、扩展性支持上，并不需要传统关系数据库的一些特征，例如：Schema、事务、完整SQL查询支持等等，因此在分布式环境下的性能相对于传统的关系数据库有较大的提升。</p><h5 id="Key-value-store-特点："><a href="#Key-value-store-特点：" class="headerlink" title="Key-value store 特点："></a>Key-value store 特点：</h5><p>– 只支持一些基本操作<br>– 分布式<br>– 冗余<br>– 容错<br>– 高可靠性  </p><h5 id="Key-Value-存储系统"><a href="#Key-Value-存储系统" class="headerlink" title="Key-Value 存储系统"></a>Key-Value 存储系统</h5><ol><li>Dynamo是亚马逊的 key-value 模式的存储平台，可用性和扩展性都很好，性能也不错：读写访问中99.9%的响应时间都在300ms 内</li><li>Memcached是一个自由开源的,高性能,分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度.</li><li>Redis 是一个开源的、内存中的数据结构存储系统，与memcached 类似，区别是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件</li></ol><h4 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h4><ol><li>Redis本质上是一个键值模型的内存数据库，整个数据库加载在内存中进行数据操作，并定期通过异步操作把数据库数据写回到硬盘上进行保存。</li><li>redis的性能非常出色，在一台普通的电脑上，每秒可以处理超过10万次读写操作。</li><li>redis可以用作缓存和队列系统中，可以为每个键设置生存时间，生存时间到期后会自动删除，还支持“发布/订阅”的消息模式。</li><li>Redis 支持的数据类型包括 string(字符串)、 list(列表)、 set(集合)<br>、hash（哈希表）等。</li></ol><h4 id="Redis适用场合"><a href="#Redis适用场合" class="headerlink" title="Redis适用场合"></a>Redis适用场合</h4><p>• 缓存应用<br>• 分布式集群架构中的session管理<br>• 取最新N个数据的操作<br>• 排行榜应用<br>• 网站访问统计<br>• 任务队列  </p><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="unix上配置"><a href="#unix上配置" class="headerlink" title="unix上配置"></a>unix上配置</h3><h4 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">• wget http://download.redis.io/releases/redis-3.2.8.tar.gz  </div><div class="line">• tar xzf redis-3.2.8.tar.gz  </div><div class="line">• cd redis-3.2.8  </div><div class="line">• make  </div><div class="line">• 启动Redis服务  </div><div class="line">– src/redis-server  </div><div class="line">• 客户端连接验证  </div><div class="line">– src/redis-cli  </div><div class="line">• 停止 Redis 实例  </div><div class="line">– src/redis-cli shutdown</div></pre></td></tr></table></figure><h4 id="配置-Redis"><a href="#配置-Redis" class="headerlink" title="配置 Redis"></a>配置 Redis</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">• Redis 的配置文件为redis.conf 文件  </div><div class="line">• port  </div><div class="line">监听端口，默认为 6379  </div><div class="line">• timeout  </div><div class="line">设置客户端连接时的超时时间，单位为秒。  </div><div class="line">• loglevel  </div><div class="line">log 等级分为 4 级，debug,verbose,notice和warning，生产环境下一般开启notice </div><div class="line">• logfile  </div><div class="line">配置 log 文件地址，默认使用标准输出，即打印在命令行终端的窗口上  </div><div class="line">• bind：  </div><div class="line">指定 Redis 只接收来自于该IP地址的请求，如果不进行设置，那么将处理所有请求  </div><div class="line">• maxmemory：  </div><div class="line">设置 redis 能够使用的最大内存</div></pre></td></tr></table></figure><h3 id="windows上配置"><a href="#windows上配置" class="headerlink" title="windows上配置"></a>windows上配置</h3><h4 id="安装服务"><a href="#安装服务" class="headerlink" title="安装服务"></a>安装服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --service-install redis.windows.conf</div></pre></td></tr></table></figure><h4 id="卸载服务"><a href="#卸载服务" class="headerlink" title="卸载服务"></a>卸载服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --service-uninstall</div></pre></td></tr></table></figure><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --service-start</div></pre></td></tr></table></figure><h4 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis-server --service-stop</div></pre></td></tr></table></figure><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">redis.windows.conf 中 第386行 requirepass #中修改替换#</div></pre></td></tr></table></figure><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">## redis.windows.conf</div><div class="line">默认的端口号：</div><div class="line">        # Accept connections on the specified port, default is 6379.</div><div class="line">        # If port 0 is specified Redis will not listen on a TCP socket.</div><div class="line">        port 6379</div></pre></td></tr></table></figure><h4 id="远程连接别人的数据库"><a href="#远程连接别人的数据库" class="headerlink" title="远程连接别人的数据库"></a>远程连接别人的数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">redis-cli.exe -h ip地址 -p 端口号 -a &quot;密码&quot;</div><div class="line">例如：</div><div class="line">redis-cli.exe -h 10.25.160.83 -p 6379 -a &quot;123456&quot;</div></pre></td></tr></table></figure><h4 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping</div><div class="line">响应 PONG 表示连接成功</div><div class="line">使用命令 auth 123456 ##修改密码为123456</div></pre></td></tr></table></figure><h3 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h3><ol><li><p>插入数据  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set name ljs</div></pre></td></tr></table></figure></li><li><p>查询数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get name</div></pre></td></tr></table></figure></li><li><p>删除键值  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">del name</div></pre></td></tr></table></figure></li><li><p>验证键是否存在  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exsists name</div></pre></td></tr></table></figure></li><li><p>返回所有 key  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keys *  </div><div class="line">keys mylist*</div></pre></td></tr></table></figure></li><li><p>设置一个 key 的过期时间(单位:秒)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">expire name 10</div></pre></td></tr></table></figure></li><li><p>移除给定 key 的过期时间 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">persist name</div></pre></td></tr></table></figure></li><li><p>选择数据库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select</div></pre></td></tr></table></figure></li><li><p>将当前数据库中的 key 转移到其它数据库中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">move name 1</div></pre></td></tr></table></figure></li><li><p>返回值的类型 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type name</div></pre></td></tr></table></figure></li><li><p>测试连接是否存活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping</div></pre></td></tr></table></figure></li><li><p>返回当前数据库中 key 的数目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dbsize</div></pre></td></tr></table></figure></li><li><p>监视–实时转储收到的请求  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monitor</div></pre></td></tr></table></figure></li><li><p>删除当前选择数据库中的所有 key  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flushdb</div></pre></td></tr></table></figure></li><li><p>删除所有数据库中的所有 key  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flashall</div></pre></td></tr></table></figure></li></ol><h3 id="Redis数据类型–strings-类型及操作"><a href="#Redis数据类型–strings-类型及操作" class="headerlink" title="Redis数据类型–strings 类型及操作"></a>Redis数据类型–strings 类型及操作</h3><p>&emsp;&emsp;string 是最简单的类型 ，一个 key 对应一个value<br>&emsp;&emsp;redis 的 string 可以包含任何数据，比如jpg图片或者序列化的对象，从内部实现来看其实 string 可以看作 byte数组，最大上限是 1G 字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">• set  </div><div class="line">– set name ljs  </div><div class="line">• Setnx：如果 key 已经存在，返回 0  </div><div class="line">– setnx name ljs  </div><div class="line">• Setex：指定此键值对应的有效期 ,时间单位为秒  </div><div class="line">– setex user 100 ljs  </div><div class="line">• setrange ：设置指定 key 的 value 值的子字符串，从指定的位置开始替换字符  </div><div class="line">setrange name 3 @gmail.com  </div><div class="line">• mset ：一次设置多个 key 的值  </div><div class="line">mset key1 ljs key2 lkr  </div><div class="line">• getrange ：获取指定 key 的 value 值的子字符串  </div><div class="line">getrange name 0 6  </div><div class="line">• mget :一次获取多个 key 的值  </div><div class="line">mget key1 key2 key3  </div><div class="line">incr:对 key 的值做加加操作  </div><div class="line">incr age  </div><div class="line">• incrby :同 incr 类似，加指定值  </div><div class="line">incrby age 5  </div><div class="line">• decr :对 key 的值做的是减减操作  </div><div class="line">decr age  </div><div class="line">• decrby :同 decr，减指定值  </div><div class="line">decrby age 5  </div><div class="line">• append :给指定 key 的字符串值追加 value,返回新字符串值的长度  </div><div class="line">append name @126.com  </div><div class="line">• strlen :取指定 key 的 value 值的长度  </div><div class="line">strlen name</div></pre></td></tr></table></figure></p><h3 id="Redis数据类型–hash-类型及操作"><a href="#Redis数据类型–hash-类型及操作" class="headerlink" title="Redis数据类型–hash 类型及操作"></a>Redis数据类型–hash 类型及操作</h3><p>&emsp;&emsp;Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，相较于将对象的每个字段存成单个string类型，将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">• hset :设置 hash field 为指定值  </div><div class="line">hset myhash name ljs  </div><div class="line">• hget :获取指定的 hash field  </div><div class="line">hget myhash name  </div><div class="line">• Hmset:同时设置 hash 的多个 field  </div><div class="line">hmset myhash name ljs age 20  </div><div class="line">• hmget :获取全部指定的 hash filed  </div><div class="line">hmget myhash name age password  </div><div class="line"></div><div class="line">hlen :返回指定 hash 的 field 数量  </div><div class="line">hlen myhash  </div><div class="line">• hdel  </div><div class="line">hdel myhash field1  </div><div class="line">• hkeys:返回 hash 的所有 field  </div><div class="line">hkeys myhash  </div><div class="line">• hvals :返回 hash 的所有 value  </div><div class="line">hvals myhash  </div><div class="line">• hgetall :获取某个 hash 中全部的 filed 及 value  </div><div class="line">hgetall myhash</div></pre></td></tr></table></figure></p><h3 id="Redis数据类型–lists-类型及操作"><a href="#Redis数据类型–lists-类型及操作" class="headerlink" title="Redis数据类型–lists 类型及操作"></a>Redis数据类型–lists 类型及操作</h3><p>&emsp;&emsp;list 是一个链表结构，主要功能是 push、pop、获取一个范围的所有值等，操作中 key 理解为链表的名字。<br>&emsp;&emsp;Redis 的list类型其实就是一个每个子元素都是string类型的双向链表。链表的最大长度是(2的32次方)。我们可以通过push,pop操作从链表的头部或者尾部添加删除元素。这使得 list既可以用作栈，也可以用作队列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">• Lpush:在 key 对应 list 的头部添加字符串元素  </div><div class="line">lpush mylist world lpush mylist hello  </div><div class="line">• lrange  </div><div class="line">lrange mylist 0 1  </div><div class="line">• rpush :在 key 对应 list 的尾部添加字符串元素  </div><div class="line">rpush mylist1 world rpush mylist1 hello  </div><div class="line">• linsert :在 key 对应 list 的特定位置之前或之后添加字符串元素  </div><div class="line">linsert mylist1 before world there  </div><div class="line"></div><div class="line">• lset :设置 list 中指定下标的元素值(下标从 0 开始)  </div><div class="line">rpush mylist2 one  </div><div class="line">rpush mylist2 two  </div><div class="line">rpush mylist2 three  </div><div class="line">lset mylist2 0 four  </div><div class="line">• lrem :从 key 对应 list 中删除 count 个和 value 相同的元素  </div><div class="line">rpush mylist3 hello  </div><div class="line">rpush mylist3 hello  </div><div class="line">rpush mylist3 world  </div><div class="line">rpush mylist3 hello  </div><div class="line">rpush mylist3 hello  </div><div class="line">lrem mylist3 2 hello  </div><div class="line"></div><div class="line">• ltrim :保留指定 key 的值范围内的数据  </div><div class="line">rpush mylist4 1  </div><div class="line">rpush mylist4 2  </div><div class="line">rpush mylist4 3  </div><div class="line">rpush mylist4 4  </div><div class="line">rpush mylist4 5  </div><div class="line">ltrim mylist4 1 3  </div><div class="line">• lpop :从 list 的头部删除元素，并返回删除元素  </div><div class="line">lpop mylist4  </div><div class="line"></div><div class="line">• rpop :从 list 的尾部删除元素，并返回删除元素  </div><div class="line">rpop mylist4  </div><div class="line">• lindex :返回名称为 key 的 list 中 index 位置的元素  </div><div class="line">lindex mylist4 0  </div><div class="line">• llen :返回 key 对应 list 的长度  </div><div class="line">llen mylist4</div></pre></td></tr></table></figure></p><h3 id="Redis数据类型–sets-类型及操作"><a href="#Redis数据类型–sets-类型及操作" class="headerlink" title="Redis数据类型–sets 类型及操作"></a>Redis数据类型–sets 类型及操作</h3><p>&emsp;&emsp;Redis 的 set 是 string 类型的无序集合。 set 元素最大可以包含(2 的 32 次方)个元素。<br>&emsp;&emsp;可以对集合进行添加删除元素，通过key对多个集合求交并差等操作， 操作中key 理解为集合的名字。<br>&emsp;&emsp;set 是通过 hash table 实现的， hash table 会随着添加或者删除自动的调整大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">• sadd  </div><div class="line">sadd myset hello  </div><div class="line">sadd myset world  </div><div class="line">sadd myset hello  </div><div class="line">• smembers ：查看 myset 中的所有元素  </div><div class="line">smembers myset  </div><div class="line">• srem ：删除名称为 key 的 set 中的元素 member  </div><div class="line">srem myset hello  </div><div class="line">• spop ：随机删除名称为 key 的 set 中一个元素  </div><div class="line">spop myset  </div><div class="line"></div><div class="line">• Sdiff:返回第一个 set集合与第二个 set集合的差集  </div><div class="line">sadd myset1 one  </div><div class="line">sadd myset1 two  </div><div class="line">sadd myset1 three  </div><div class="line">sadd myset2 two  </div><div class="line">sadd myset2 three  </div><div class="line">sadd myset2 four  </div><div class="line">sdiff myset2 myset1  </div><div class="line">• sdiffstore :返回第一个 set集合与第二个set集合的差集，并将结果存为另一个 set  </div><div class="line">sdiffstore myset3 myset2 myset1  </div><div class="line"></div><div class="line">• Sinter:返回所有给定 key 的交集 （获取共同的朋友）  </div><div class="line">sinter myset1 myset2  </div><div class="line">• sinterstore :返回所有给定 key 的交集，并将结果存为另一个 key  </div><div class="line">sinterstore myset4 myset2 myset1  </div><div class="line">• Sunion:返回所有给定 key 的并集  </div><div class="line">sunion myset2 myset1  </div><div class="line">• sunionstore :返回所有给定 key 的并集，并将结果存为另一个 key  </div><div class="line">sunionstore myset5 myset2 myset1  </div><div class="line">• Scard:返回名称为 key 的 set 的元素个数  </div><div class="line">scard myset2</div></pre></td></tr></table></figure></p><h3 id="Redis数据类型–sorted-sets类型及操作"><a href="#Redis数据类型–sorted-sets类型及操作" class="headerlink" title="Redis数据类型–sorted sets类型及操作"></a>Redis数据类型–sorted sets类型及操作</h3><p>&emsp;&emsp;sorted set 是 set 的一个升级版本， 它在 set 的基础上增加了一个分数属性，使我们能够获得分数最高、最低的前n个元素，获得指定分数范围内的元素等与分数有关的操作。<br>&emsp;&emsp;和 set 一样，sortedset也是string类型元素的集合，不同的是每个元素都会关联一个 double类型的 score。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">• zadd：向名称为 key的zset中添加元素member，score用于设定分数。如果该元素已经存在，则根据score 更新该元素的分数。  </div><div class="line">zadd key score member  </div><div class="line">zadd myzset 1 one  </div><div class="line">zadd myzset 2 two  </div><div class="line">zadd myzset 3 two  </div><div class="line">zrange myzset 0 -1 withscores  </div><div class="line">• zrem :删除名称为 key 的 zset 中的元素 member  </div><div class="line">zrem myzset two  </div><div class="line"></div><div class="line">• Zincrby：给成员增加指定分数  </div><div class="line">zadd myzset1 1 one  </div><div class="line">zadd myzset1 2 two  </div><div class="line">zincrby myzset1 1 one  </div><div class="line">zrange myzset1 0 -1withscores   </div><div class="line">• zrank ：返回zset 中名称为key的member元素的排名(按score从小到大排序)即下标  </div><div class="line">zrank myzset1 two  </div><div class="line"></div><div class="line">• zrevrank：返回zset中名称为key的member元素的排名(按score从大到小排序)即下标  </div><div class="line">zrevrank myzset1 two  </div><div class="line">• zrevrange ：按 score 从大到小排序，再取出全部元素  </div><div class="line">zrevrange myzset1 0 -1 withscores  </div><div class="line">• zrangebyscore ：返回集合中 score 在给定区间的元素  </div><div class="line">zrangebyscore myzset1 2 3 withscores  </div><div class="line">• zcount ：返回集合中 score 在给定区间的数量  </div><div class="line">zcount myzset1 2 3  </div><div class="line"></div><div class="line">• zcard ：返回集合中元素个数  </div><div class="line">zcard myzset1  </div><div class="line">• zscore ：返回给定元素对应的 score  </div><div class="line">zscore myzset1 two  </div><div class="line">• zremrangebyrank ：删除集合中排名在给定区间的元素  </div><div class="line">zremrangebyrank myzset1 3 3  </div><div class="line">• zremrangebyscore ：删除集合中 score 在给定区间的元素  </div><div class="line">zremrangebyscore myzset1 1 2</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&amp;emsp;&amp;emsp;Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。
    
    </summary>
    
    
      <category term="Redis" scheme="http://www.normantriste.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>软件开发工程师（Java）题库二</title>
    <link href="http://www.normantriste.top/2017/10/30/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88Java%EF%BC%89%E9%A2%98%E5%BA%93%E4%BA%8C/"/>
    <id>http://www.normantriste.top/2017/10/30/软件开发工程师（Java）题库二/</id>
    <published>2017-10-30T08:21:00.000Z</published>
    <updated>2017-11-09T00:58:52.560Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发工程师（Java）题库二<br><a id="more"></a></p><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><ol><li><p>计划职能的主要任务就是确定<br><span style="color:skyblue;">A. 组织的目标和实现目标的途径</span><br>B. 组织结构的蓝图<br>C. 组织中的工作设计<br>D. 组织的领导方式  </p></li><li><p>企业在做计划时，应优先保证下列哪一组计划<br>A. 局部计划、作业计划、长期计划<br>B. 项目计划、管理计划、短期计划<br><span style="color:skyblue;">C. 综合计划、战略计划、长期计划</span><br>D. 局部计划、战略计划、中期计划  </p></li><li><p>J2EE 中，哪个类的什么方法用于创建对话<br><span style="color:skyblue;">A. HttpServletRequest的getSession</span><br>B. HttpServletResponse的newSession<br>C. HtttpSession的newInstance<br>D. HttpSession的getSession  </p></li><li><p>编写Servlet 的doPost方法时，需要抛出异常为<br><span style="color:skyblue;">A. ServletException， IOException</span><br>B. ServletException， RemoteException<br>C. HttpServletException， IOException<br>D. HttpServletException， RemoteException  </p></li><li><p>在J2EE中，对于Httpservlet类的描述，错误的是？<br><span style="color:skyblue;">A. 我们自己编写的Servlet继承了Httpservlet类，一定需覆盖doPost或者doGet</span><br>B. HttpServlet类扩展了GenericServlet类，实现了GenericServlet类的抽象方法<br>C. HttpServlet类中处理客户请求和响应时所使用的两个接口是：HttpServletRequest和HttpServletResponse<br>D. 我们自己编写的servlet继承了Httpservlet类，一般只需要覆盖doPost方法，不必覆盖servive（）方法，因为一个service（）方法会调用doPost或者doGet方法E-R图  </p></li><li><p>用以下方法中哪一个把目标应用作为bean激活的定制事件的监听者（listener）注册<br>A. void addPropertyChangeListener()<br>B. void firePropertyChange()<br>C. removeXXXListener()<br><span style="color:skyblue;">D. void addXXXListener()</span>   </p></li><li><p>数据流图（DFD）是用于描述结构化方法中（）阶段的工具<br>A. 可行性分析<br>B. 详细设计<br><span style="color:skyblue;">C. 需求分析</span><br>D. 程序编码  </p></li><li><p>不同的数据库管理系统支持不同的数据模型，下列哪种不属于常用的数据模型？<br>A. 关系模型<br>B. 网状模型<br>C. 层次模型<br><span style="color:skyblue;">D. 链表模型</span>   </p></li><li><p>下面关于数据持久化概念的描述，错误的是<br>A. 保存在内存中数据的状态是瞬时状态<br>B. 持久状态的数据在关机后数据依然存在<br>C. 数据可以由持久状态转换为瞬时状态<br><span style="color:skyblue;">D. 将数据转换为持久状态的机制称为数据持久化</span>   </p></li><li><p>哪种应用类型在分离的层次上处理表示逻辑、业务逻辑、及数据库的可交互性？<br><span style="color:skyblue;">A. 分布应用</span><br>B. 以服务器为中心的应用<br>C. 客户/服务器应用<br>D. 单块应用  </p></li><li><p>以下从四种不同的作用域中得到Bean的实例，说法错误的是<br><span style="color:skyblue;">A. page是指当前Web应用程序的所有JSP文件中取得实例，从Page对象中获取JavaBean；</span><br>B. request是指在当前的用户请求中取得实例，从ServletRequest对象中获取JavaBean<br>C. session是指在当前的用户会话中取得实例，常用于一个用户登录在网站上全过程不同请求之间共享数据，从HttpSession对象中获取JavaBean<br>D. application是指在当前的应用程序中取得实例，常用于同一个应用程序不同用户访问时共享数据，从ServletContext对象中获取JavaBean  </p></li><li><p>在三层结构中，数据访问层承担的责任是？<br>A. 定义实体类<br><span style="color:skyblue;">B. 数据的增删改查操作</span><br>C. 业务逻辑的描述<br>D. 页面展示和控制转发  </p></li><li><p>使用HTTPSession接口来跟踪你的Servlets中会话数据。为把值加入到此会话对象，你应使用哪个函数？<br>A. setValue()<br>B. addValue()<br><span style="color:skyblue;">C. putValue()</span><br>D. addSession()  </p></li><li><p>软件的横向重用是指重用不同应用领域中的软件元素。（    ）是一种典型的、原始的横向重用机制。<br>A. 对象<br>B. 构件<br><span style="color:skyblue;">C. 标准函数库</span><br>D. 设计模式  </p></li><li><p>在哪一层上监听客户所作的远程方法调用，并重定向服务器上的远程RMI服务的调用？<br>A. Remote Reference 层<br>B. Application层<br><span style="color:skyblue;">C. Stub/Skeleton 层</span><br>D. Transport 层运行出错，抛出异常  </p></li><li><p>划分软件生存周期的阶段时所应遵循的基本原则是<br>A. 各阶段的任务尽可能相关性<br><span style="color:skyblue;">B. 各阶段的任务尽可能相对独立</span><br>C. 各阶段的任务在时间上连续<br>D. 各阶段的任务在时间上相对独立  </p></li><li><p>一个软件项目是否进行开发的结论是在哪个文档中作出的<br>A. 软件开发计划<br><span style="color:skyblue;">B. 可行性报告</span><br>C. 需求分析说明书<br>D. 测试报告  </p></li><li><p>下列关于ORALCE数据库的描述,不正确的是？<br><span style="color:skyblue;">A. 索引表含ROWID值</span><br>B. 一个事务即使不被提交,也会被写入到重做日志中<br>C. 拥有不同大小的回滚段没有任何益处<br>D. COMMIT后,数据不一定立即写入数据文件中  </p></li><li><p>下列不是Linux系统进程类型的是<br>A. 交互进程<br>B. 批处理进程<br>C. 守护进程<br><span style="color:skyblue;">D. 就绪进程</span>   </p></li><li><p>Linux系统中对名为fido的文件用chmod 551 fido 进行了修改，则它的许可权是?<br>A. -rwxr-xr-x<br>B. -rwxr–r<br>C. -r–r–r<br><span style="color:skyblue;">D. -r-xr-x-x </span>  </p></li><li><p>如果事务T1需要两次读取同一数据项A，但是在两次读操作的间隔中，另一个事务T2改变了A的值，那么此并发操作所引起的问题是？<br>A. 丢失更新<br>B. 死锁<br><span style="color:skyblue;">C. 不可重复读</span><br>D. 读脏数据  </p></li><li>下面的程序执行后没有报错，但数据总保存不到数据库，最可能的原因是   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">imain</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"> SessionFactory sf=<span class="keyword">new</span> Configration().configure().buildSessionFactory();</div><div class="line"> Session session=sf.openSession();</div><div class="line"> Medal medal=<span class="keyword">new</span> Medal();</div><div class="line"> medal.setOwner(“totong”);</div><div class="line"> medal.setType(“Gold medal”);</div><div class="line"> session.save(user);</div><div class="line"> session.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>A. 配置文件配置有误<br>B. 没有在配置文件中包含对映射文件的声明<br>C. 没有对持久化操作捕捉异常<br><span style="color:skyblue;">D. 没有开启事务</span>   </p><ol><li><p>结构化系统分析主要是通过下列哪项进行分析的<br>A. 算法分解<br>B. 控制结构分解<br>C. 数据结构分解<br><span style="color:skyblue;">D. 处理功能分解</span>   </p></li><li><p>结构化设计方法采用变换分析和事务分析技术实现<br>A. 从数据结构导出程序结构<br>B. 从模块结构导出程序结构<br>C. 从模块结构导出数据结构<br><span style="color:skyblue;">D. 从数据流图导出初始化结构图静态存根客户端</span>   </p></li><li><p>过程域对象在Hibernate中代表<br>A. 业务逻辑操作<br>B. 应用层操作<br><span style="color:skyblue;">C. 数据库层操作</span><br>D. 组件对象操作  </p></li><li><p>HQL不支持聚合函数有?<br>A. count()<br>B. avg(…)<br>C. count(…)<br><span style="color:skyblue;">D. count(?)</span>   </p></li><li><p>Under which conditions will check () return true when called from a different class?<br>A. Check() can never return true<br>B. Check() can return true when setXY is called by multiple threads.<br>C. Check() can return true when multiple threads call setX and setY separately.<br><span style="color:skyblue;">D. Check() can only return true if SyncTest is changed to allow x and y to be set separately.</span>   </p></li><li><p>对实际应用问题建立数学模型并求得结果后，还需要根据建模的目的和要求，利用相关知识，结合研究对象的特点，进行模型分析。模型分析工作一般不包括<br>A. 模型的合理性分析<br>B. 模型的误差分析<br><span style="color:skyblue;">C. 模型的先进性分析</span><br>D. 参数的灵敏性分析  </p></li><li><p>在软件开发过程中，如果项目的规模和工作量大，项目具有较大的开发团队，需求存在明显的优先级划分或系统具有较技术风险，则最时候使用哪种生命周期？<br><span style="color:skyblue;">A. 增量模型</span><br>B. 快速原型<br>C. 瀑布模型<br>D. 螺旋模型  </p></li><li><p>我国《计算机软件保护条例》所称的“发表”的含义是指将软件作品<br>A. 出版发行<br><span style="color:skyblue;">B. 公之于众</span><br>C. 在版权局登记<br>D. 以某种物质形式固定下来  </p></li><li><p>能有效地监督组织各项计划的落实和执行情况，发现计划与实际之间的差距，这一管理环节是<br>A. 计划<br>B. 组织<br>C. 领导<br><span style="color:skyblue;">D. 控制</span>   </p></li><li><p>下列关于合同变更与变更前后合同之间关系的正确说法是<br>A. 合同变更后，已经履行的债务失去了法律依据，应该恢复原状<br>B. 合同变更部分条款后，未变更的部分视为已经变更<br>C. 合同变更后，已经存在的损害赔偿请求权不复存在<br><span style="color:skyblue;">D. 合同变更必须以原合同关系存在为前提</span>   </p></li><li><p>下面关于远程接口描述正确的是<br>A. 远程接口监听客户调用的远程方法调用并重定向对服务器上的远程RMI服务器的调用。<br>B. 用唯一名注册的远程对象的接口<br><span style="color:skyblue;">C. 其声明的方法可被客户远程地调用的接口。</span><br>D. 声明和定义了可被客户远程地调用的方法的接口  </p></li><li><p>古人云：“运筹于帷幄之中，决胜于千里之外”，这里的“运筹帷幄”反映了管理的哪一个职能？<br><span style="color:skyblue;">A. 计划职能</span><br>B. 组织职能<br>C. 领导职能<br>D. 控制职能领导技能  </p></li><li><p>预先决定要做什么、为什么要做、何时去做、在何地做、由什么人做以及如何做，是管理哪一项职能的任务？<br>A. 控制<br>B. 组织<br>C. 领导<br><span style="color:skyblue;">D. 计划</span>   </p></li><li><p>不紧急也不重要的工作采用（    ）方式解决<br>A. 妥协<br>B. 迁就<br><span style="color:skyblue;">C. 回避</span><br>D. 合作  </p></li><li><p>能有效地监督组织各项计划的落实和执行情况，发现计划与实际之间的差距，这一管理环节是<br>A. 计划<br>B. 组织<br>C. 领导<br><span style="color:skyblue;">D. 控制</span>   </p></li><li><p>某软件企业开发了一套能够同硬件结合以提高设备性能的软件产品，向国家专利局申请方法发明专利，获得了专利权，并为该软件产品冠以“昆仑”商品专用标识，但未进行商标注册上市销售。此情况下，该软件产品不可能得到我国（    ）的保护<br>A. 著作权法<br>B. 专利法<br><span style="color:skyblue;">C. 商标法</span><br>D. 刑法  </p></li><li><p>某公司欲开发一个软件系统的在线文档帮助系统，用户可以在任何一个查询上下文中输入查询关键字，如果当前查询环境下没有相关内容，则系统会将查询按照一定的顺序转发给其他查询环境。基于上述需求，采用(    )最为合适<br>A. 责任链模式<br>B. 桥接模式<br><span style="color:skyblue;">C. 装饰模式</span><br>D. 适配器模式  </p></li><li><p>某服务器软件系统能够正确运行并得出计算结果，但存在“系统出错后不能在要求的时间内恢复到正常状态”和“对系统进行二次开发时总要超过半年的时间”两个问题，上述问题依次与质量属性中的(     )相关<br>A. 可用性和性能<br>B. 性能和可修改性<br>C. 性能和可测试性<br><span style="color:skyblue;">D. 可用性和可修改性</span>   </p></li></ol><h3 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h3><ol><li><p>属于推动我国ITO发展的因素有？<br><span style="color:skyblue;">A. 价格优势明显<br>B. 印度示范影响<br>C. 通过认证企业增多<br>D. 著名跨国企业示范</span>  </p></li><li><p>下列属于外包特征的是<br><span style="color:skyblue;">A. 企业的各项活动可以在时间并行，空间上分散进行</span><br>B. 企业把某些业务转移给外部操作，是自身组织结构扁平化<br><span style="color:skyblue;">C. 依托信息技术与外部资源整合<br>D. 企业在规模收缩中扩张</span>   </p></li><li><p>使用JavaBean的好处有哪些？<br><span style="color:skyblue;">A. JavaBean拥有标准化接口的优点，在开发期有可视化编程工具的支持，在运行期有JSP和J2EE连接器的支持<br>B. JavaBean更明确的把WEB页面的设计和软件的设计区分开来<br>C. JavaBean可以在多个应用程序中重用</span><br>D. JavaBean可以实现安全性、事务行为、并发性和持久性</p></li><li><p>MVC模式的优势有哪些？<br><span style="color:skyblue;">A. MVC模式使应用程序的结构更加清晰，通过将代码按照层次划分为业务逻辑/数据层、用户界面和应用流程控制这三个层次，能够增强代码的稳定性。</span><br>B. MVC模式实现了很好的分布式组件架构<br><span style="color:skyblue;">C. 对于项目开发而言，MVC三层的分离有利于在项目小组内按照小组成员各自的擅长进行分工，有利于三个部分并行开发、加快项目进度<br>D. MVC模块功能的划分有利于在代码修改过程中进行模块的隔离，而不需要把具有不同功能的代码混杂在一起造成混乱</span>  </p></li><li><p>Which two statements are true regarding the creation of a default constructor?<br>A. The default constructor initializes method variables.<br>B. The compiler always creates a default   constructor for every class.<br><span style="color:skyblue;">C. The default constructor initializes the instance variables declared in the class.<br>D. When a class has only constructors with parameters, the compiler does not create<br>a default constructor.</span>  </p></li><li><p>下面不是Hibernate映射文件中包含的内容？<br><span style="color:skyblue;">A. 数据库连接信息<br>B. Hibernate属性参数</span><br>C. 主键生成策略<br>D. 属性数据类型  </p></li><li><p>weblogic与EJB相关的部署描述文件有<br><span style="color:skyblue;">A. ejb-jar.xml<br>B. weblogic-ejb-jar.xml</span><br>C. weblogic.xml<br><span style="color:skyblue;">D. weblogic-cmp-rdbms-jar.xml</span> </p></li><li><p>一般情况下，关系数据模型与对象模型之间有哪些匹配关系<br><span style="color:skyblue;">A. 表对应类</span><br>B. 记录对应对象<br><span style="color:skyblue;">C. 表的字段对应类的属性<br>D. 表之间的参考关系对应类之间的依赖关系 </span> </p></li><li><p>计划工作是一种最基本管理活动，应遵循的原则有：<br><span style="color:skyblue;">A. 改变航道原则<br>B. 限定因素原则<br>C. 承诺原则<br>D. 弹性原则</span>  </p></li><li><p>管理者要使自己主管的工作达到一定的标准和要求，必须具备管理所需的相应管理技能。   这些管理技能主要包括<br>A. 领导技能<br><span style="color:skyblue;">B. 技术技能<br>C. 人际技能<br>D. 概念技能</span>  </p></li></ol><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><ol><li>ServletContext类的getRequestDispatcher()可以接受相对路径。<span style="color:skyblue;">(X)</span>  </li><li>Service()方法表示Servlet生命周期的结束。<span style="color:skyblue;">(X)</span>  </li><li>Bean的事件是java.util.EventObject的子类。<span style="color:skyblue;">(√)</span>  </li><li>在JPQA查询中，排除相同的对象用distinct。<span style="color:skyblue;">(√)</span>  </li><li>对原生SQL查询的控制是通过Query接口进行的。<span style="color:skyblue;">(X)</span>  </li><li>SessionFactory是重量级的对象，不应该随意创建。如果系统中只有一个数据库存储源，只需要创建一个。<span style="color:skyblue;">(√)</span>  </li><li>在Hibernate中，有通用的数据库方言可以使用。<span style="color:skyblue;">(X)</span>  </li><li>使用Session的delete()会把对象的状态从数据库中移除<span style="color:skyblue;">(√)</span>  </li><li>计划是一种约束，会降低组织的灵活性。<span style="color:skyblue;">(X)</span>  </li><li>专业技术人员在创新开始最为关键的环节是确认创新的机会，其战略意识和市场意识是创新获得成功的重要基础。<span style="color:skyblue;">(√)</span> </li></ol><h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h3><ol><li>控制共享资源的并发访问，需要用到的java关键字是<u style="color:skyblue;">synchronized</u>。 </li><li>构建Struts2应用的最基础的几个类库是：struts2-core、commons-logging、<u style="color:skyblue;">xwork-core</u>、freamarker以及ognl。  </li><li>Struts 2以<u style="color:skyblue;">FilterDispacher</u>为核心控制器。  </li><li>Hibernate处理事务的接口是<u style="color:skyblue;">Tranction</u>。  </li><li>如果不想让实体Bean的某些属性映射到表的字段，用<br><u style="color:skyblue;">@Column</u>注释。  </li><li>数据库封锁技术中主要有两种封锁：排他型封锁和<u style="color:skyblue;">共享</u>型封锁。  </li><li>一般来说，在管理软件中，软件生存周期各个阶段的工作量以<u style="color:skyblue;">维护阶段</u>所占的比例最大。  </li><li>数据库关系模型中，数据联系是通过表间的<u style="color:skyblue;">关键码</u>实现的。  </li><li>概念结构设计的目的是产生一个能反映<u style="color:skyblue;">需求</u>的概念模型。  </li><li>模块内部的算法设计在结构化方法的<u style="color:skyblue;">详细设计</u>阶段进行。  </li></ol><h3 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h3><ol><li><p>简述软件外包风险的防范策略？<br>答：<span style="color:skyblue;">软件外包风险是指软件外包的实施结果相对于预期目标的变动程度，即软件外包的预期收益的变动程度。软件外包双方必须增强风险防范意识，软件外包风险防范的策略主要有：<br>1、制定正确的外包策略。外包前要认真分析实施外包的前提是否具备，实施软件外包的可能性有多大等。<br>2、准确的核算和控制外包综合成本。<br>3、周密的考察、确定和管理接包方。<br>4、强化项目单点联系管理。发包方任命专人定点管理，承接方制定专人汇报联系。<br>5、双方实施项目全程管理。</span>  </p></li><li><p>项目开发要经历了哪几个阶段？简要说明项目的体系统架构：（客户层，表示层）web层，业务层，数据层？<br>答：<br><span style="color:skyblue;">需求分析，设计(找用例，写用例文本，找实体，编写数据字典，画数据流图)，编码，测试，部署；<br>客户层：IE浏览器，Applet小应用程序，在客户度允许<br>表示层：html静态页面，jsp页面，servlet在服务器上运行；<br>业务层：实现业务逻辑，服务器提供系统级服务，如事务管理，安全性，并非控制<br>数据层：如dao部分，实现对数据的增删改查等。 </span> </p></li><li><p>Hibernate中持久化对象的生命周期以及各种状态直接的区别，并描述相互之间是如何转换的？<br>答：<span style="color:skyblue;"><br>Hibernate中持久化对象的生命周期有临时态、持久态和游离态三种。<br>1).处于临时态的对象主键值为空，并且未与session关联，数据未保存到数据库中<br>2).处于持久态的对象与session关联起来，持久化后对象中的数据被保存到数据库中，并且主键值按照.hbm.xml文件中配置的生成方式生成相应的值<br>3).处于游离态的对象脱离了session的管理，是持久化后的一种状态，主键值按照.hbm.xml文件中配置的生成方式生成相应的值<br>当new一个新的对象时，该对象处于临时态<br>当该对象被当作session的参数使用的时候，该对象处于持久态<br>事务提交，session关闭后，该对象处于游离态 </span>   </p></li><li><p>用英文翻译以下两个句子 </p></li></ol><p>1) 服务提供商为了不断促进业务进程而采用的某种激励方式。当通过降低成本，提高收入或提高效率使客户受益时，服务提供商也同样受益。<br><span style="color:skyblue;">1.The service provider has some form of incentive for constantly improving the business process. When the client benefits (through reduced expenses, greater revenues or improved efficiencies), so does the service provider.</span>  </p><p>2) 外包合同条款的一个方面。用于描述产品归属者的变更情况以及知识产权。“知识产权”是无形资产，它包含一定程度的创造性劳动，例如软件设计等。该条款保护合同双方维护其知识产权的权力，包括使用权、出版权和复制权。<br><span style="color:skyblue;">2.An aspect of the outsourcing contract‘s Terms and Conditions. Specifies when any change of title to products occurs. It also specifies intellectual property rights. “Intellectual property” is intangible and involves some degree of creative effort, such as software design. This clause protects both parties‘ rights to retain control over their intellectual property, including the rights to their use, publication and copying.</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发工程师（Java）题库二&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.normantriste.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="题库" scheme="http://www.normantriste.top/tags/%E9%A2%98%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>软件开发工程师（Java）题库一</title>
    <link href="http://www.normantriste.top/2017/10/29/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88Java%EF%BC%89%E9%A2%98%E5%BA%93%E4%B8%80/"/>
    <id>http://www.normantriste.top/2017/10/29/软件开发工程师（Java）题库一/</id>
    <published>2017-10-29T15:59:00.000Z</published>
    <updated>2017-11-09T00:58:19.338Z</updated>
    
    <content type="html"><![CDATA[<p>软件开发工程师（Java）题库一<br><a id="more"></a></p><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><p>1.下面有关服务外包说法正确的是<br>A 服务外包是指企业将价值链中原本有自身提供的具有基础的、共性的、核心的业务或业务流程剥离出去，交给外部专业服务提供商完成的经济活动<br><span style="color:skyblue;">B 企业通过外包可以重组价值链，优化资源配置，降低成本，并增加企业竞争力</span><br>C 某银行将信用卡数据外包给专业的公司，这属于服务流程外包<br>D 按服务外包业务类型可将外包分为：信息技术外包、后勤服务外包、客户关系外包和研发外包</p><p>2.下面做法无助于有效沟通的是<br>A 学会夸奖他人<br>B 预防情感定式<br>C 恰当的称呼对方<br><span style="color:skyblue;">D 提高说话音量</span>  </p><p>3.社会主义职业道德的核心是<br>A 集体主义<br>B 爱岗敬业<br><span style="color:skyblue;">C 全心全意为人民服务</span><br>D 诚实守信  </p><p>4.下列哪一种叙述是正确的<br>A abstract修饰符可修饰字段、方法和类<br>B 抽象方法的body部分必须用一对大括号{ }包住<br>C 声明抽象方法，大括号可有可无<br><span style="color:skyblue;">D 声明抽象方法不可写出大括号</span>  </p><p>5.如下代码，输出结果是什么？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">aMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        i++;</div><div class="line">        <span class="keyword">return</span> i;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Test test = <span class="keyword">new</span> Test();</div><div class="line">        test.aMethod();</div><div class="line">        <span class="keyword">int</span> j = test.aMethod();</div><div class="line">        System.out.println(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>A 0<br>B 1<br>C 2<br><span style="color:skyblue;">D 编译失败</span>  </p><p>6.下列哪种说法是正确的<br>A 实例方法可直接调用超类的实例方法<br>B 实例方法可直接调用超类的类方法<br>C 实例方法可直接调用其他类的实例方法<br><span style="color:skyblue;">D 实例方法可直接调用本类的类方法</span>  </p><p>7.用于调用存储过程的对象是？<br>A ResultSet<br>B DriverManager<br><span style="color:skyblue;">C CallableStatemet</span><br>D PreparedStatement  </p><p>8.在Servlet处理请求的方式为？<br>A 以进程的方式<br>B 以程序的方式<br><span style="color:skyblue;">C 以线程的方式</span><br>D 以响应的方式  </p><p>9.如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    Base() &#123; </div><div class="line">        System.out.print(<span class="string">"Base"</span>); </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alpha</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Alpha();</div><div class="line">        <span class="keyword">new</span> Base();</div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>结果是什么？<br>A Base<br><span style="color:skyblue;">B BaseBase</span><br>C 编译失败<br>D 运行时抛出异常  </p><p>10.在Servlet的生命周期中，容器只调用一次的方法是?<br>A service<br>B getServletConfig<br><span style="color:skyblue;">C init</span><br>D destroy  </p><p>11.下面关于垃圾收集的说法正确的是？<br>A 一旦一个对象成为垃圾，就立刻被收集掉<br>B 对象空间被收集掉之后，会执行该对象的finalize方法<br>C finalize方法和C++的析构函数是完全一回事情<br><span style="color:skyblue;">D   一个对象成为垃圾是因为不再有引用指着它，但是线程并非如此</span>  </p><p>12.Which method is used by a Servlet to place its session ID in a URL that is written to the servlet’s response output stream?<br>A The encodeURL method of the HttpServletRequest interface<br><span style="color:skyblue;">B The encodeURL method of the   HttpServletResponse interface.</span><br>C The rewriteURL method of the HttpServletRequest interface<br>D The rewriteURL method of the HttpServletResponse interface<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">1. Java Servlet API 中引用 Session 机制来追踪客户的状态。Servlet API 中定义了 javax.servlet.http.HttpSession 接口，</div><div class="line">Servlet 容器必须实现这个接口。</div><div class="line">2.当一个 Session 开始时，Servlet 容器将创建一个 HttpSession 对象，Servlet 容器为 HttpSession 分配一个唯一标识符，称为 Session ID。Servlet 容器将 Session ID 作为 Cookie 保存在客户的浏览器中。每次客户发出 HTTP 请求时，Servlet 容器可以从 HttpRequest 对象中读取 Session ID，然后根据 Session ID 找到相应的 HttpSession 对象，从而获取客户的状态信息。</div><div class="line">3.当客户端浏览器中禁止 Cookie，Servlet 容器无法从客户端浏览器中取得作为 Cookie 的 Session ID，也就无法跟踪客户状态。  </div><div class="line">Java Servlet API 中提出了跟踪 Session 的另一种机制，如果客户端浏览器不支持 Cookie，Servlet 容器可以重写客户请求的 URL，把 Session ID 添加到 URL 信息中。  </div><div class="line">4. HttpServletResponse 接口提供了重写 URL 的方法：public java.lang.String encodeURL(java.lang.String url)  </div><div class="line">该方法的实现机制为：   </div><div class="line">● 先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。   </div><div class="line">● 再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。   </div><div class="line">我们可以对网页中的链接稍作修改，解决以上问题：</div><div class="line">修改前：</div><div class="line">&lt;a href=“maillogin.jsp“&gt;   </div><div class="line">修改后：  </div><div class="line">&lt;a href=“&lt;%=response.encodeURL(“maillogin.jsp“)%&gt;“&gt;</div></pre></td></tr></table></figure></p><p>13.类Test1定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>)<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span></span>&#123;</div><div class="line"><span class="number">2</span>)  <span class="keyword">public</span> <span class="keyword">float</span> aMethod（<span class="keyword">float</span> a，<span class="keyword">float</span> b）&#123; </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125; </div><div class="line"><span class="number">3</span>)</div><div class="line"><span class="number">4</span>)&#125;</div></pre></td></tr></table></figure></p><p>将以下哪种方法插入行3是不合法的<br>A public float aMethod（float a， float b，float c）{ return 0;}<br><span style="color:skyblue;">B public float aMethod（float c，float d）{ return 0;}</span><br>C public int aMethod（int a， int b）{ return 0;}<br>D private float aMethod（int a，int b，int c）{ return 0;}  </p><p>14.在JavaScript中如何验证一个数据是否是数字？<br>A 如果用Integer.parseInt(value)有误就不是数字<br>B int I = value 若报错就不是数字<br>C 没有方法验证<br><span style="color:skyblue;">D 利用isNaN(value)   返回的boolean进行判断</span>  </p><p>15.下面哪项不是response对象的方法<br>A setContentType(String contentTypestr)<br>B setHeader(String headername,String headervalue)<br><span style="color:skyblue;">C getParameter(String str)</span><br>D sendError(int errorcode)  </p><p>16.JavaScript中判断服务器已经响应的标志是？<br><span style="color:skyblue;">A xmlHttp.readyState == 4</span><br>B xmlHttp.readyState == 3<br>C xmlHttp.readyState == 2（请求成功）<br>D xmlHttp.readyState == 1  </p><p>17.下面哪项不属于SQL语句的子类<br>A 数据定义语言(DDL)<br>B 数据查询语言(DQL)<br>C 事务控制语言(TCL)<br><span style="color:skyblue;">D 数据插入语言(DIL)</span>  </p><p>18.以下从四种不同的作用域中得到Bean的实例，说法错误的是？<br><span style="color:skyblue;">A page是指当前Web应用程序的所有JSP文件中取得实例，从Page对象中获取JavaBean；</span><br>B request是指在当前的用户请求中取得实例，从ServletRequest对象中获取JavaBean<br>C session是指在当前的用户会话中取得实例，常用于一个用户登录在网站上全过程不同请求之间共享数据，从HttpSession对象中获取JavaBean<br>D application是指在当前的应用程序中取得实例，常用于同一个应用程序不同用户访问时共享数据，从ServletContext对象中获取JavaBean  </p><p>19.有关过滤器init()方法错误的是<br><span style="color:skyblue;">A 每次调用过滤器时都会执行init方法</span><br>B init方法可以访问FilterConfig对象。     FilterConfig对象提供了对servlet环境及web.xml文件中指派的过滤器名的访问<br>C 利用init将FilterConfig对象存放在一个字段中，以便doFilter方法能够访问servlet环境或过滤器名<br>D FilterConfig对象具有一个getInitParameter方法，它能够访问部署描述符文件（web.xml）中分配的过滤器的初始化参数  </p><p>20.有关C/S、B/S结构下列说法错误的是<br>A 在C/S结构，即客户端/服务器结构中，有专门的数据库服务器，但客户端还要运行客户端应用程序，这也叫做胖客户端<br>B 在B/S结构中，客户端在浏览器中只负责表示层逻辑的实现，业务逻辑和数据库都在服务器端运行。也就是说，应用程序部署在服务器端，客户端通过浏览器访问应<br>C 通常B/S结构中，客户端发送HTTP请求消息传给服务器，服务器将请求传递给Web应用程序，Web应用程序处理请求，并把相应的HTML页面传给客户端<br><span style="color:skyblue;">D Web应用是基于C/S结构的，也就是客户端/服务器结构</span>  </p><p>21.GRANT update ON inventory TO joe WITH GRANT OPTION;此语句有什么作用<br>A 一个系统权限被授予用户JOE<br><span style="color:skyblue;">B 一个对象权限被授予用户JOE</span><br>C 用户JOE被授予在这个对象上的所有权限<br>D 一个系统权限和一个对象权限被授予用户JOE  </p><p>22.需要读取一个比较大的文本文件，这个文件里有很多字节的数据，那么读这类文件下列最合适的选项是哪个？<br>A new FileInputStream(“file.name”);<br>B new InputStreamReader(new FileInputStream(“file.name”));<br><span style="color:skyblue;">C new BufferedInputStream(new FileInputStream(“file.name”));</span><br>D new RandomAccessFile raf=new RandomAccessFile(“myfile.txt”,rw);  </p><p>23.关于正则表达式声明6位数字的邮编，以下代码正确的是？<br>A var  reg = /\d6/<br>B var  reg = \d{6}\<br><span style="color:skyblue;">C var  reg = /\d{6}/</span><br>D var  reg = new RegExp(“\d{6}”)  </p><p>24.在数据库系统中，提供数据与应用程序间物理独立性的是？<br>A 外模式/模式映像<br><span style="color:skyblue;">B 模式/内模式映像</span><br>C 外模式/内模式映像<br>D 子模式/模式映像  </p><p>25.下列关于视图的说法中错误的是<br>A 视图是从一个或多个基本表导出的表，它是虚表<br>B 视图可以被用来对无权用户屏蔽数据<br><span style="color:skyblue;">C 视图一经定义就可以和基本表一样被查询和更新</span><br>D 视图可以用来定义新的视图  </p><p>26.如果一个事务在故障发生之前完成，但是它并没有到达检查点，则系统恢复时应对该事务执行<br><span style="color:skyblue;">A REDO操作</span><br>B UNDO操作<br>C RESTART操作<br>D NULL操作   </p><p>27.在Oracle中，有一个教师表teacher的结构如下:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ID NUMBER(5)</div><div class="line">NAME VARCHAR2(25)</div><div class="line">EMAIL VARCHAR2(50)</div></pre></td></tr></table></figure></p><p>下面哪个语句显示没有Email地址的教师姓名?<br>A SELECT name FROM teacher WHERE email = NULL<br>B SELECT name FROM teacher WHERE email &lt;&gt; NULL<br><span style="color:skyblue;">C SELECT name FROM teacher WHERE email IS NULL</span><br>D SELECT name FROM teacher WHERE email IS NOT NULL  </p><p>28.下列关于栈的叙述正确的是？<br>A 栈是非线性结构<br>B 栈是一种树状结构<br>C 栈具有先进先出的特征<br><span style="color:skyblue;">D 栈具有后进先出的特征</span>  </p><p>29.下面数据结构中，属于非线性的是？<br>A 线性表<br><span style="color:skyblue;">B 树</span><br>C 队列<br>D 堆栈  </p><p>30.结构化程序设计所规定的三种基本控制结构是<br>A 输入、处理、输出<br>B 树形、网形、环形<br><span style="color:skyblue;">C 顺序、选择、循环</span><br>D 主程序、子程序、函数  </p><p>31.软件设计中划分模块的一个准则是<br>A 低内聚低耦合<br>B 低内聚高耦合<br><span style="color:skyblue;">C 高内聚低耦合</span><br>D 高内聚高耦合  </p><p>32.软件测试的目的是<br>A 评价软件的质量<br><span style="color:skyblue;">B 发现软件的错误</span><br>C 找出软件中的所有错误<br>D 证明软件是正确的  </p><p>33.使用白盒测试方法时，确定测试数据应根据（    ）和指定的覆盖标准<br><span style="color:skyblue;">A 程序的内部逻辑</span><br>B 程序的复杂程度<br>C 使用说明书<br>D 程序的功能  </p><p>34.根据我国《计算机信息系统安全保护条例》，我国计算机安全保护实行的是<br>A 全面保护<br><span style="color:skyblue;">B 等级保护</span><br>C 特殊保护<br>D 集中保护  </p><p>35.按沟通是对媒介的依赖程度可以将沟通分为<br>A 单向沟通和双向沟通<br><span style="color:skyblue;">B 直接沟通和间接沟通</span><br>C 语言沟通和非语言沟通<br>D 正式沟通和非正式沟通  </p><p>36.下列关于从业人员与职业道德关系的说法中，正确的是<br>A 道德是说教，说教会扼杀员工的积极性和创造性<br>B 只有在大家普遍遵守道德的前提下，道德才会起作用<br>C 道德意识是与生俱来的，没必要对员工做规范性的教育和培训<br><span style="color:skyblue;">D 任何从业人员在走上工作岗位以前都要接受职业道德教育</span>  </p><p>37.所谓职业道德是指人们在职业活动中形成的<br>A 外在的、非强制性的规范<br><span style="color:skyblue;">B 内在的、非强制性的约束机制</span><br>C 外在的、强制性的管理规范<br>D 内在的、强制性措施  </p><p>38.职业理想分为三个层次，分别为：劳动是个人的谋生手段；从事爱好的工作，施展个人的才智；工作的目的是承担社会义务。这三个层次的关系是<br>A 内容不同，每个员工只能适用一种层次<br>B 目的有本质区别，三者是互相排斥的<br>C 三个层次逐步递进，相互联系，不能并行适用同一个人<br><span style="color:skyblue;">D 三者虽有区别，但并行不悖，适用于同一个人</span>  </p><p>39.从实际生活来看，一些人就业后发展缓慢甚至遭受挫折、失败，问题可能处在<br><span style="color:skyblue;">A 职业道德修养不够</span><br>B 社会关系不硬<br>C 家庭生活不幸福<br>D 角色转型不成功  </p><p>40.职业道德修养包括<br>A 职业规范修养、职业礼仪修养、职业道德理论修养<br>B 职业着装修养、职业礼貌用语修养、职业道德情感修养<br><span style="color:skyblue;">C 职业理论知识修养、职业道德情感修养、职业道德意志</span><br>D 职业合作修养、职业交谈修养、职业接待修养  </p><h3 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h3><p>1.使用JavaBean的好处有哪些？<br><span style="color:skyblue;">A JavaBean拥有标准化接口的优点，在开发期有可视化编程工具的支持，在运行期有JSP和J2EE连接器的支持<br>B JavaBean更明确的把WEB页面的设计和软件的设计区分开来<br>C JavaBean可以在多个应用程序中重用</span><br>D JavaBean可以实现安全性、事务行为、并发性和持久性。  </p><p>2.链表具有的特点是<br><span style="color:skyblue;">A 不必事先估计存储空间</span><br>B 可随机访问任一元素<br><span style="color:skyblue;">C 插入删除不需要移动元素<br>D 所需空间与线性表长度成正比</span>  </p><p>3.String类的IndexOf()方法返回的类型是？<br>A Int16<br><span style="color:skyblue;">B Int32<br>C int</span><br>D long  </p><p>4.按照学生平均成绩(avg_grade) 将students表中的数据检索出来，下面SQL语句正确的是？<br><span style="color:skyblue;">A SELECT <em> FROM students ORDER BY avg_grade</em></span><br>B SELECT  FROM students GROUP BY avg_grade ASC<br><span style="color:skyblue;">C SELECT <em> FROM students ORDER BY avg_grade DESC<br>D SELECT </em> FROM students ORDER by avg_grade asc</span>  </p><p>5.下面哪个语句正确地声明一个整型的二维数组<br>A int   a[10][10]   =   new   int[][]；<br><span style="color:skyblue;">B int   a[][]   =   new   int[10][10]；<br>C int   [][]a   =   new   int[10][10]；<br>D int   []a[]   =   new   int[10][10]；</span>  </p><p>6.下面哪些语句能够正确地生成5个空字符串？<br><span style="color:skyblue;">A String a[ ]=new String[5];for(int i=0;i&lt;5;a[i++]=””);<br>B String a[ ]={“ “,””,””,””};</span><br>C String a[5];<br>D String [ ]a=new   String[5];for(int   i=0；i&lt;5；a[i++]=null);  </p><p>7.关于JavaScript里的xml处理，以下说明正确的是<br>A Xml是种可扩展标记语言，格式更规范，是作为未来html的替代<br><span style="color:skyblue;">B Xml一般用于传输和存储数据，是对html的补充，两者的目的不同<br>C 在JavaScript里解析和处理xml数据时，因为浏览器的不同，其做法也不同<br>D 在IE浏览器里处理xml，首先需要创建ActiveXObject对象</span>  </p><p>8.下面有助于沟通能力培养的是<br><span style="color:skyblue;">A 加强知识的学习，不断武装自己<br>B 锤炼健康的心理素质<br>C 加强自身的思想品德修养<br>D 掌握一定的沟通技巧</span>  </p><p>9.下列属于外包特征的是<br><span style="color:skyblue;">A 企业的各项活动可以在时间并行，空间上分散进行<br>B 企业把某些业务转移给外部操作，是自身组织结构扁平化<br>C 依托信息技术与外部资源整合<br>D 企业在规模收缩中扩张</span>  </p><p>10.在专业学习中训练职业道德行为的要求是<br>A 参加文化学习、专业学习和专业实习<br>B 向劳动模范学习，向先进人物学习<br><span style="color:skyblue;">C 增强职业意识、遵守职业规范<br>D 重视技能训练，提高职业素养</span>  </p><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><p>1.Java 语言规定构造方法不可以重载。<span style="color:skyblue;">(X)</span><br>2.break语句只中断某一层的循环<span style="color:skyblue;">(√)</span><br>3.在程序中，对象是通过一种抽象数据类型来描述的，这种抽象数据类型称为类（class）<span style="color:skyblue;">(√)</span><br>4.在人际交往中，只考虑自己需要收人尊敬的感受，而不顾对方的感受，则容易导致沟通失败，这是违反了沟通的平衡原则。<span style="color:skyblue;">(√)</span><br>5.沟通能力是沟通者思想、知识、思维、心理等素质的体现，是一项综合能力。<span style="color:skyblue;">(√)</span><br>6.JSP会先解释成Servlet源文件，然后编译成Servlet类文件<span style="color:skyblue;">(√)</span><br>7.每当用户端运行JSP时，jspInit()方法都会运行一次<span style="color:skyblue;">(X)</span><br>8.利用equals()方法判定Date类时，判断的是对象的值而不是对象的地址。<span style="color:skyblue;">(√)</span><br>9.类加载器加载程序运行所需要的所有类，它通过区分本机文件系统的类和网络系统导入的类增加安全性。<span style="color:skyblue;">(√)</span><br>10.在同一个类的不同构造方法中调用该类的其它构造方法需要使用this(…)的形式，this(…)不能在构造方法的第一行调用。<span style="color:skyblue;">(X)</span></p><h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h3><p>1.Java是严格区分大小写、完全面向对象的语言<u style="color:skyblue;">类</u>是程序的基本单位。<br>2.服务外包是指企业将其<u style="color:skyblue;">非核心业务</u>外包出去，利用外部最优秀的专业化团队来承接其业务。<br>3.<u style="color:skyblue;">接口</u>只描述系统所提供的服务，而不包含服务的实现细节。<br>4.在Java中，字符串和数组是作为<u style="color:skyblue;">对象</u>出现的。<br>5.在运行时，由java解释器自动引入，而不用import语句引入的包是<u style="color:skyblue;">java.lang</u>。<br>6.Sockets技术是构建在<u style="color:skyblue;">TCP</u>协议之上。<br>7.JDBC使用<u style="color:skyblue;">Class.forName( )</u>方法加载和注册驱动程序。<br>8.所有的过滤器必须明确的实现 Init()、doFileter()和<u style="color:skyblue;">destroy()</u>三个方法。<br>9.Java中实现多线程一般使用两种方法，一是继承Thread类，二是<u style="color:skyblue;">实现Runnable方法</u>。</p><p>10.测试工作就是进行输入、接受输出、检验结果，不深入代码细节，这样的测试方法称为<u style="color:skyblue;">黑盒测试</u>。</p><h3 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h3><p>1.写出两种形式的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">　　 <span class="comment">//在自己内部定义自己一个实例，是不是很奇怪？</span></div><div class="line">　　 <span class="comment">//注意这是private 只供内部调用</span></div><div class="line">　　 <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">　　 <span class="comment">//这里提供了一个供外部访问本class的静态方法，可以直接访问　　</span></div><div class="line">　　 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">　　　　 <span class="keyword">return</span> instance; 　　</div><div class="line">　　 &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">　　<span class="comment">//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　　　　</span></div><div class="line">　　<span class="comment">//使用时生成实例，提高了效率！</span></div><div class="line">　　<span class="keyword">if</span> (instance==<span class="keyword">null</span>)</div><div class="line">　　　　instance＝<span class="keyword">new</span> Singleton();</div><div class="line"><span class="keyword">return</span> instance; 　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？<br><span style="color:skyblue;"><br>a: 两种形式 dtd(文档结构) schema<br>b: 本质区别:schema本身是xml的，可以被XML解析器解析(这也是从DTD上发展schema的根本目的)<br>c:有DOM,SAX,STAX等<br>DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问<br>SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问<br>STAX:Streaming API for XML (StAX)<br>xml文档有两种定义方法：<br>dtd：数据类型定义（data type definition），用以描述XML文档的文档结构，是早期的XML文档定义形式。<br>schema：其本身是基于XML语言编写的，在类型和语法上的限定能力比dtd强，处理也比较方便，因为此正逐渐代替dtd成为新的模式定义语言。</span></p><p>3.给你一个:驱动程序A,数据源名称为B,用户名称为C,密码为D,数据库表为T，请用JDBC检索出表T的所有数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> dao;</div><div class="line"><span class="keyword">import</span> java.sql.Connection;</div><div class="line"><span class="keyword">import</span> java.sql.DriverManager;</div><div class="line"><span class="keyword">import</span> java.sql.ResultSet;</div><div class="line"><span class="keyword">import</span> java.sql.SQLException;</div><div class="line"><span class="keyword">import</span> java.sql.Statement;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"> <span class="keyword">private</span> String className=<span class="string">""</span>A<span class="string">""</span>;</div><div class="line"> <span class="keyword">private</span> String url=<span class="string">""</span>B<span class="string">""</span>;</div><div class="line"> <span class="keyword">private</span> String user=<span class="string">""</span>C<span class="string">""</span>;</div><div class="line"> <span class="keyword">private</span> String password=<span class="string">""</span>D<span class="string">""</span>;</div><div class="line"> <span class="keyword">private</span> Connection connection;</div><div class="line"> <span class="keyword">private</span> Statement statement;</div><div class="line"> <span class="keyword">private</span> ResultSet resultSet;</div><div class="line"> <span class="function"><span class="keyword">public</span> Connection <span class="title">getConn</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">   Class.forName(className);</div><div class="line">   connection = DriverManager.getConnection(url, user, password);</div><div class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">   <span class="comment">// TODO 自动生成 catch 块</span></div><div class="line">   e.printStackTrace();</div><div class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">   <span class="comment">// TODO 自动生成 catch 块</span></div><div class="line">   e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> connection;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span> </span>&#123;</div><div class="line">  connection=getConn();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">   statement = connection.createStatement();</div><div class="line">   resultSet = statement.executeQuery(sql);</div><div class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">   <span class="comment">// TODO 自动生成 catch 块</span></div><div class="line">   e.printStackTrace();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> resultSet;</div><div class="line"> &#125;</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  Test test = <span class="keyword">new</span> Test();</div><div class="line">  ResultSet set = test.executeQuery(<span class="string">""</span>select * from T<span class="string">""</span>);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.用中文翻译以下两个句子：</p><p>1) Business process outsourcing. The transfer of internal business processes, such as customer relationship management, finance &amp; accounting, human resources and procurement, to an external service provider that improves these processes and administers these functions to an agreed service standard and, typically, at a reduced cost.<br><span style="color:skyblue;"><br>1.业务流程外包。将诸如客户关系管理、金融及会计、人力资源及采购等内部业务流程在降低成本的前提下外包给外部的服务供应商，以按照约定的服务标准改善这些进程、管理这些功能。</span></p><p>2) Executive level person who oversees sourcing governance elements in an organization. Typically, the CSO and his or her team is responsible for overseeing every sourcing decision made.<br><span style="color:skyblue;"><br>2.在机构中纵览外包管理事宜的执行层次人员。通常来说，首席外包官及其团队负责纵览任何外包决定的制定”</span></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件开发工程师（Java）题库一&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.normantriste.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="题库" scheme="http://www.normantriste.top/tags/%E9%A2%98%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>面向切面编程(AOP)</title>
    <link href="http://www.normantriste.top/2017/10/28/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-AOP/"/>
    <id>http://www.normantriste.top/2017/10/28/面向切面编程-AOP/</id>
    <published>2017-10-28T07:53:00.000Z</published>
    <updated>2017-11-06T08:33:23.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h3><p><strong>面向方面编程（Aspect Oriented Programming）</strong><br>&emsp;&emsp;Spring的一个关键的组件就是 AOP框架。 尽管如此，Spring IoC容器并不依赖于AOP，这意味着可以自由选择是否使用AOP，AOP提供强大的中间件解决方案，这使得Spring IoC容器更加完善。<br>&emsp;&emsp;Spring AOP的出现是为了取代EJB中的事务机制，它有这种声明式的事务机制，其实AOP的这种思想早就已经有了，并不是一种什么新的技术，也并不是说专门由java这里来实现的 。<br>&emsp;&emsp;面向切面编程（AOP）提供另外一种角度来思考程序结构，通<br>过这种方式弥补了面向对象编程（OOP）的不足。<br><a id="more"></a></p><h3 id="为何使用AOP"><a href="#为何使用AOP" class="headerlink" title="为何使用AOP"></a>为何使用AOP</h3><p>• 高度模块化，使得我们的系统更易实现和更易维护<br>• 使每个模块承担的责任更清晰，提高代码的可追踪性<br>• 解决设计时两难的局面，在不需改动原先代码的情况下推迟不必要的需求的实现<br>• 提高代码的重用性<br>• 加速系统的开发和部署，提高程序员的开发效率<br>• 降低系统开发的成本</p><h3 id="AOP应用范围"><a href="#AOP应用范围" class="headerlink" title="AOP应用范围"></a>AOP应用范围</h3><p>• Persistence（持久化）<br>• Transaction management（事务管理）<br>• Security（安全）<br>• Logging，tracing，profiling and monitoring（日志，跟踪，优化，监控）<br>• Debugging（调试）<br>• Authentication（认证）<br>• Context passing（上下文传递）<br>• Error/Exception handling（错误/异常处理）<br>• Lazy loading（懒加载）<br>• Performance optimization（性能优化）<br>• Resource pooling（资源池）<br>• Synchronization（同步）  </p><h3 id="AOP涉及到的概念"><a href="#AOP涉及到的概念" class="headerlink" title="AOP涉及到的概念"></a>AOP涉及到的概念</h3><ul><li>Aspect(切面):指横切性关注点的抽象即为切面,它与类相似,只是两者的关注点不一样,类是对物体特征的抽象,而切面是对横切性关注点的抽象.  </li><li>joinpoint(连接点):所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点,实际上joinpoint还可以是field或类构造器)  </li><li>Pointcut(切入点):所谓切入点是指我们要对哪些joinpoint进行拦截的定义.  </li><li>Advice(通知):所谓通知是指拦截到joinpoint之后所要做的事情就是通知.通知分<br>为前置通知,后置通知,异常通知,最终通知,环绕通知  </li><li>Target(目标对象):代理的目标对象  </li><li>Weave(织入):指将aspects应用到target对象并导致proxy对象创建的过程称为织入</li><li>Introduction(引入):在不修改类代码的前提下,Introduction可以在运行期为类动态地添加一些方法或Field.  </li></ul><h4 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h4><ol><li>前置通知（Beforeadvice）：在某连接点之前执行的逻辑，但这个逻辑不能阻止连接点的执行。</li><li>后置通知（After advice）：当某连接点退出的时候执行的逻辑。</li><li>环绕通知（Around advice）：包围连接点退出的时候执行的逻辑。</li><li>抛出异常后逻辑（After throwing advice):在方法抛出异常退出时执行的逻辑。</li></ol><p><strong>前置通知</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 前置通知</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> logBeforeAdvice implements MethodBeforeAdvice&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method,Object[] args,Object target)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        System.out.println(<span class="string">"前置通知-------开始"</span>);</div><div class="line">        System.out.println(<span class="string">"目标对象"</span>+target.getClass().getName());</div><div class="line">        System.out.println(<span class="string">"调用方法"</span>+method.getName());</div><div class="line">        System.out.println(<span class="string">"调用方法传的参数"</span>+Arrays.toString(args));</div><div class="line">        System.out.println(<span class="string">"前置通知-------结束"</span>);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 实际对象dao --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"aop.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBrforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 代理对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"aop.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的目标对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>logBeforeAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Test.java</span></div><div class="line">    <span class="comment">// 加载xml</span></div><div class="line">    BeanFactory factory = ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">// 有代理，有通知</span></div><div class="line">    IuserDao.daoProxy = (IuserDao)factory.getBean(<span class="string">"userDaoProxy"</span>);</div><div class="line">    daoProxy.insertUser(<span class="string">"tomcat"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//运行结果：</span></div><div class="line">    前置通知-------开始</div><div class="line">    目标对象：aop.UserDaoImpl</div><div class="line">    调用方法：inserUser</div><div class="line">    调用方法传的参数：[tomcat]</div><div class="line">    前置通知-------结束</div><div class="line">    inserUser方法结果</div></pre></td></tr></table></figure><p><strong>后置通知&amp;环绕通知&amp;抛出通知</strong>  </p><ol><li>前置通知和后置通知适合用于打印日志</li><li>环绕通知适合用于做事务管理</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 实际对象dao --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"aop.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBrforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 后置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAftereAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogAftereAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 环绕通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logAroundAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogAroundAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 抛出通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logthrowsAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogthrowsAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 代理对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"aop.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的目标对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            </div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>logBeforeAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>logAftereAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 后置通知 --&gt;</span> </div><div class="line">            <span class="comment">&lt;!-- 环绕通知相当于前置加后置，使用环绕通知就不要前置通知和后置通知了 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>logAroundAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 环绕通知 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>logthrowsAdvice<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 抛出通知 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 环绕通知</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAroundAdvice</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Oberride</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation methodInvocation)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        System.out.println(<span class="string">"环绕通知----------开始"</span>);</div><div class="line">        </div><div class="line">        <span class="comment">// 真正调用方法的语句</span></div><div class="line">        Object retrunValue = methodInvocation.proceed(); </div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"环绕通知----------结束"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> returnValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 抛出异常通知</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> logThrowsAdvice implements ThrowsAdvice&#123;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method,Object[] args,Exception ex)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        System.out.println(<span class="string">"抛出通知-------开始:"</span> + ex.getMessage());</div><div class="line">        System.out.println(<span class="string">"目标对象"</span>+target.getClass().getName());</div><div class="line">        System.out.println(<span class="string">"调用方法"</span>+method.getName());</div><div class="line">        System.out.println(<span class="string">"调用方法传的参数"</span>+Arrays.toString(args));</div><div class="line">        System.out.println(<span class="string">"抛出通知-------结束"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可以重载方法，具体到哪一类异常，例如</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Method method,Object[] args,ArithmeticException ex)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">        <span class="comment">//算术异常</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="AOP切入点-NameMatchMethodPointcut"><a href="#AOP切入点-NameMatchMethodPointcut" class="headerlink" title="AOP切入点(NameMatchMethodPointcut)"></a>AOP切入点(NameMatchMethodPointcut)</h4><h5 id="切入点的类型"><a href="#切入点的类型" class="headerlink" title="切入点的类型"></a>切入点的类型</h5><ol><li>NameMatchMethodPointcut</li></ol><ul><li>匹配方法名称</li><li>无法对重载(Overload)的方法名进行匹配，因为它仅对方法名进行匹配，不会考虑参数相关信息，而且也没有提供可以指定参数匹配信息的途径。</li></ul><ol><li>AbstractRegexpMethodPointcut</li></ol><ul><li>根据正则表达式计算切入点，要匹配完整的类名和方法名</li><li>对应的Advisor是RegexpMethodPointcutAdvisor,会根据当前JDK版本来决定使用jdkRegexpMethodPointcut,还是Perl5RegexpMethodPointcut.</li></ul><ol><li>动态</li></ol><ul><li>ControlFlowPointcut</li></ul><h6 id="NameMatchMethodPointcut-匹配方法名称"><a href="#NameMatchMethodPointcut-匹配方法名称" class="headerlink" title="NameMatchMethodPointcut(匹配方法名称)"></a>NameMatchMethodPointcut(匹配方法名称)</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 实际对象dao --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"aop.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBrforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 切入点(pointcut):NameMatchMethodPiontcut 根据方法名称匹配，无法精确匹配重载的方法 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointCut"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.NameMatchMethodPointcut"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span>&gt;</span><span class="comment">&lt;!-- mappedNames是固定的 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>insertUser<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 精确匹配:匹配方法名称为insertUser的方法 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>insert*<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 模糊匹配:匹配方法名称以inser开始的方法 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 顾问(advisor):通知(advice)+切入点(pointCut) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"advisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"logBeforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 切入点 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"pointCut"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 代理对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"aop.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的目标对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>advisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 顾问 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>整合的顾问，作用跟上面的一样(代码更精简)</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 实际对象dao --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"aop.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBrforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 顾问(advisor):NameMatchMethodPointcutAdvisor 根据方法名称匹配，无法精确匹配重载的方法 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"advisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.NameMatchMethodPointcutAdvisor"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"logBeforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 切入点 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span>&gt;</span><span class="comment">&lt;!-- mappedNames是固定的 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>insertUser<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 精确匹配:匹配方法名称为insertUser的方法 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>insert*<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 模糊匹配:匹配方法名称以inser开始的方法 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 代理对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"aop.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的目标对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>advisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 顾问 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p><h6 id="AbstractRegexpMethodPointcut-根据正则表达式计算切入点"><a href="#AbstractRegexpMethodPointcut-根据正则表达式计算切入点" class="headerlink" title="AbstractRegexpMethodPointcut(根据正则表达式计算切入点)"></a>AbstractRegexpMethodPointcut(根据正则表达式计算切入点)</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 实际对象dao --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"aop.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBrforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 顾问(advisor):通知(advice)+切入点(pointCut) ：RegexpMethodPointcut ：根据正则表达式匹配完整方法路径--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"advisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"logBeforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 切入点 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span>&gt;</span><span class="comment">&lt;!-- mappedNames是固定的 --&gt;</span></div><div class="line">        <span class="comment">&lt;!--</span></div><div class="line"><span class="comment">            正则表达式：</span></div><div class="line"><span class="comment">                . 匹配任意单个字符</span></div><div class="line"><span class="comment">                + 匹配前一字符出现1次或多次</span></div><div class="line"><span class="comment">                * 匹配前一字符出现0次或多次</span></div><div class="line"><span class="comment">                \ 转义</span></div><div class="line"><span class="comment">        --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aop.IUserDao.insertUser<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 精确匹配:匹配方法的匹配完整路径：包名+类名+方法名 --&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aop\.I.+Dao\.insert.*<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="comment">&lt;!-- 模糊匹配:匹配方法名称以inser开始的方法 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 代理对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"aop.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的目标对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>advisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 顾问 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h6 id="ControlFlowPointcut-了解"><a href="#ControlFlowPointcut-了解" class="headerlink" title="ControlFlowPointcut(了解)"></a>ControlFlowPointcut(了解)</h6><p>&emsp;&emsp;ControlFlowPointcut是Spring所提供的的类：判断在方法的执行堆栈中，某个指定类的某个方法中，是否曾经要求你的目标对象执行某个动作。由于这是在执行时期才会确定是否接入Advices，因此是Spring提供的动态Pointcut功能。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">&lt;!-- applicationContext_4.xml --&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 实际对象dao --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"aop.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"some"</span> <span class="attr">class</span>=<span class="string">"aop.Some"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDaoProxy"</span> <span class="attr">ref</span>=<span class="string">"userDaoProxy"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 在方法二中不需要 --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 前置通知 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logBeforeAdvice"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBrforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- </span></div><div class="line"><span class="comment">    切入点(pointcut):ControlFlowPointcut 动态匹配目标对象的方法</span></div><div class="line"><span class="comment">    当代理对象userDaoProxy在指定类aop，Some中调用目标对象userDao中任意方法时，才会使用通知logBeforeAdvice</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"pointcut"</span> <span class="attr">class</span>=<span class="string">"aop.advice.LogBeforeAdvice"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"aop.Some"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 顾问(advisor):通知(advice)+切入点(pointCut) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"advisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.DefaultPointcutAdvisor"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"logBeforeAdvice"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 切入点 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"pointcut"</span> <span class="attr">ref</span>=<span class="string">"pointCut"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 代理对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDaoProxy"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.framework.ProxyFactoryBean"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"proxyInterfaces"</span> <span class="attr">value</span>=<span class="string">"aop.IUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 代理的目标对象 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"target"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 通知 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">propery</span> <span class="attr">name</span>=<span class="string">"interceptorNames"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>advisor<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!-- 顾问 --&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Some.java</span></div><div class="line"><span class="comment">// 方法一：</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> IUserDao userDaoProxy;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDaoProxy</span><span class="params">(IUserDao userDaoProxy)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.userDaoProxy = userDaoProxy;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"some.insert()..."</span>);</div><div class="line">        </div><div class="line">        userDaoProxy.insertUsers();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 方法二：</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Some</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> IUserDao userDaoProxy;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"some.insert()..."</span>);</div><div class="line">        </div><div class="line">        userDaoProxy.insertUsers();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansExcception</span>&#123;</div><div class="line">        <span class="keyword">this</span> userDaoProxy = (IUserDao)applicationContext.getBean(<span class="string">"userDaoProxy"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Test.java</span></div><div class="line">BeanFactory factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext_4.xml"</span>)</div><div class="line"></div><div class="line"><span class="comment">// 动态切入点测试</span></div><div class="line">factory.getBean(<span class="string">"Some"</span>);</div><div class="line">some.insert();</div><div class="line"></div><div class="line"><span class="comment">// Some类中的方法调用的UserDao中方法，通知才会生效，在其他类中调用不会生效</span></div></pre></td></tr></table></figure><h4 id="AOP代理"><a href="#AOP代理" class="headerlink" title="AOP代理"></a>AOP代理</h4><ul><li>Spring缺省使用JAVA动态代理（dynamicproxies）来作为AOP的代理。这样任何接口都可以被代理。</li><li>Spring也支持使用CGLIB代理.对于需要代理类而不是代理接口的时候CGLIB代理是很有必要的。 如果一个业务对象并没有实现一个接口，默认就会使用CGLIB。作为面向接口编程的最佳实践，业务对象通常都会实现一个或多个接口。</li></ul><h5 id="AOP代理-静态代理"><a href="#AOP代理-静态代理" class="headerlink" title="AOP代理-静态代理"></a>AOP代理-静态代理</h5><p>代理分类为：静态代理、动态代理。</p><ol><li>所有的静态代理，代理类是你确确实实能看到的；</li><li>而动态的，是在运行期生成的，所以这两种方式我们都需要来领会。</li></ol><h5 id="AOP代理-动态代理"><a href="#AOP代理-动态代理" class="headerlink" title="AOP代理-动态代理"></a>AOP代理-动态代理</h5><p>• JDK动态代理：  </p><ol><li>Spring的AOP的默认实现就是采用jdk的动态代理机制实现的。</li><li>通过之前的分析，我们要把横切性的关注点（例如安全性检查）单独的提取出来，这就是动态代理的思想。</li><li>把散布在程序各个角落的关注点提取出来，进行模块化。</li><li>模块化的好处：即模块化之后，我们只要单独维护这个模块就可以了，不用去维护散布在各处的关注点，否则，难度大，效率低。</li><li>AOP技术应该是OO的在技术上的补充</li></ol><p><strong>AOP通过动态代理技术在运行期织入增强代码，首先了解下</strong><br><strong>AOP使用的两种代理机制：</strong><br>– 基于JDK的动态代理<br>– 基于CGlib的动态代理<br>• JDK动态代理主要涉及两个类，<br>– Java.lang.reflect.Proxy<br>– Java.lang.reflect.InvocationHandler  </p><ol><li>InvocationHandler是一个接口，可以通过实现该接口定义的横切逻辑，并通过反射机制调用目标类的代码，动态的将横切逻辑和业务逻辑编织在一起。  </li><li>Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。</li></ol><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object targetObject;<span class="comment">//代理的目标对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxyInstance</span><span class="params">(Object targetObject)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.targetObject = targetObject;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">        * 第一个参数设置代码使用的类装载器,一般采用跟目标类相同的类装载器</span></div><div class="line"><span class="comment">        * 第二个参数设置代理类实现的接口</span></div><div class="line"><span class="comment">        * 第三个参数设置回调对象,当代理对象的方法被调用时,会委派给该参数指定</span></div><div class="line"><span class="comment">        对象的invoke方法</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        <span class="keyword">return</span> </div><div class="line">        Proxy.newProxyInstance(<span class="keyword">this</span>.targetObject.getClass().getClassLoadr(),</div><div class="line">        <span class="keyword">this</span>.targetObject.getClass().getInterfaces(),<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>.targetObject, args);<span class="comment">//把方法调用委派给目标对象</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    <span class="comment">// 当目标类实现了接口，我们可以使用jdk的Proxy来生成代理对象。</span></div></pre></td></tr></table></figure><h4 id="基于CGlib的动态代理"><a href="#基于CGlib的动态代理" class="headerlink" title="基于CGlib的动态代理"></a>基于CGlib的动态代理</h4><ul><li>JDK只能为接口创建代理实例，对于那些没有通过接口定义业务方法的类，可以通过CGLib创建代理实例。</li><li>CGLib采用底层字节码技术，可以为一个类创建子类，并在子类中采用方法拦截技术拦截所有父类方法的调用，这时可以顺势织入横切逻辑。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLIBProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object targetObject;<span class="comment">//代理的目标对象</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxyInstance</span><span class="params">(Object targetObject)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.targetObject = targetObject;</div><div class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();<span class="comment">//该类用于生成代理对象</span></div><div class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.targetObject.getClass());<span class="comment">//设置父类</span></div><div class="line">        enhancer.setCallback(<span class="keyword">this</span>);<span class="comment">//设置回调对象为本身</span></div><div class="line">        <span class="keyword">return</span> enhancer.create();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args,MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> methodProxy.invoke(<span class="keyword">this</span>.targetObject, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// CGLIB可以生成目标类的子类，并重写父类非final修饰符的方法。</span></div></pre></td></tr></table></figure><h3 id="AOP编程"><a href="#AOP编程" class="headerlink" title="AOP编程"></a>AOP编程</h3><p>Spring提供了两种切面声明方式，实际工作中我们可以选用其中一种：<br>– 基于XML配置方式声明切面。<br>– 基于注解方式声明切面。  </p><p>要进行AOP编程，首先我们要在spring的配置文件中引入aop命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></div><div class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop</span></span></div><div class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="基于注解方式的AOP编程"><a href="#基于注解方式的AOP编程" class="headerlink" title="基于注解方式的AOP编程"></a>基于注解方式的AOP编程</h4><p>• 采用注解方式实现(Annotation)步骤:<br>– 采用Aspect定义切面<br>– 在Aspect定义Pointcut和Advice<br>– 启用AspectJ对源数据注解的支持（添加sechma)<br>– 将Aspect类和目标对象配置到IOC容器中  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个切面</span></div><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAdvic</span> </span>&#123;</div><div class="line">    <span class="comment">//定义一个切入点，名称是addMethod(),此方法不能有参数和返回值</span></div><div class="line">    <span class="comment">//表达式描述哪些对象的哪些方法执行 advice</span></div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* add*(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMethod</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">//定义advice ,指定在哪个切入织入此方法</span></div><div class="line">    <span class="comment">//@Around("addMethod()")</span></div><div class="line">    <span class="meta">@Before</span>(<span class="string">"addMethod()"</span>)  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</div><div class="line">    System.out.println(<span class="string">"验证用户"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. 任意公共方法的执行：</div><div class="line">    – execution(<span class="keyword">public</span> * *(..) )</div><div class="line"><span class="number">2</span>. 任何一个以<span class="string">"set"</span>开始的方法的执行：</div><div class="line">    – execution(* set*(..))</div><div class="line"><span class="number">3</span>. AccountService 接口的任意方法的执行：</div><div class="line">    – execution(* com.AccountService.*(..))</div><div class="line"><span class="number">4</span>. 定义在service包里的任意方法的执行：</div><div class="line">    – execution(* com.*.*(..))</div><div class="line"><span class="number">5</span>. 定义在service包或者子包里的任意方法的执行：</div><div class="line">    – execution(* com..*.*(..))</div></pre></td></tr></table></figure><p>启动对@AspectJ注解的支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></div><div class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop</span></span></div><div class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!--启动对@AspectJ注解的支持--&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderservice"</span> <span class="attr">class</span>=<span class="string">"com.ttc.test.service.UserServiceBean"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.ttc.test.service.LogPrint"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure><p>样例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogPrint</span> </span>&#123;</div><div class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.ttc.test.service..*.*(..))"</span>)</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyMethod</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//声明一个切入点</span></div><div class="line">    <span class="meta">@Before</span>(<span class="string">"anyMethod() &amp;&amp; args(userName)"</span>)<span class="comment">//定义前置通知</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(String userName)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@AfterReturning</span>(pointcut=<span class="string">"anyMethod()"</span>,returning=<span class="string">"revalue"</span>)<span class="comment">//定义后置通知</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReturnCheck</span><span class="params">(String revalue)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@AfterThrowing</span>(pointcut=<span class="string">"anyMethod()"</span>, throwing=<span class="string">"ex"</span>)<span class="comment">//定义例外通知</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doExceptionAction</span><span class="params">(Exception ex)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@After</span>(<span class="string">"anyMethod()"</span>)<span class="comment">//定义最终通知</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseAction</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Around</span>(<span class="string">"anyMethod()"</span>)<span class="comment">//环绕通知</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">    <span class="keyword">return</span> pjp.proceed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>采用静态配置文件实现步骤</strong><br>– 定义一个切面类，编写处理逻辑（通知）<br>– 确定连接点或切点：对象及方法<br>– 确定处理逻辑（通知）调用模式<br>– 配置  </p><p>采用静态配置文件实现<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 定义一个切面,并指定通知类 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"tasp"</span> <span class="attr">ref</span>=<span class="string">"tadvic"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 定义一个切入点，定义切入点名和匹配表达式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"allMethod"</span> <span class="attr">expression</span>=<span class="string">"execution(**.add*(..))"</span>/&gt;</span></div><div class="line"><span class="comment">&lt;!-- 定义切入点执行方法 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"check"</span> <span class="attr">pointcut-ref</span>=<span class="string">"allMethod"</span>/&gt;</span><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"deptDao"</span> <span class="attr">class</span>=<span class="string">"com.qhit.DeptDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"tadvic"</span> <span class="attr">class</span>=<span class="string">"com.qhit.TestAdvic"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p><p>使用JoinPoint可以拿到被拦截方法的参数和方法名:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">check</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</div><div class="line">    <span class="comment">//if(jp.getArgs()[0].equals("aaaa"))</span></div><div class="line">    <span class="comment">//return null;</span></div><div class="line">    <span class="comment">//else</span></div><div class="line">    System.out.println(<span class="string">"验证用户"</span>);</div><div class="line">    <span class="comment">//return jp.proceed();</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogPrint</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;&#125;定义前置通知</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReturnCheck</span><span class="params">()</span> </span>&#123;&#125;定义后置通知</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doExceptionAction</span><span class="params">()</span> </span>&#123;&#125;定义例外通知</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseAction</span><span class="params">()</span> </span>&#123;&#125;定义最终通知</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">return</span> pjp.proceed();环绕通知</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderservice"</span> <span class="attr">class</span>=<span class="string">"com.ttc.test.service.OrderServiceBean"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"log"</span> <span class="attr">class</span>=<span class="string">"com.ttc.test.service.LogPrint"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myaop"</span> <span class="attr">ref</span>=<span class="string">"log"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"mycut"</span> <span class="attr">expression</span>=<span class="string">"execution(*</span></span></div><div class="line"><span class="tag"><span class="string">            com.ttc.test.service..*.*(..))"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"mycut"</span> <span class="attr">method</span>=<span class="string">"doAccessCheck"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">"mycut"</span> <span class="attr">method</span>=<span class="string">"doReturnCheck "</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">pointcut-ref</span>=<span class="string">"mycut"</span> <span class="attr">method</span>=<span class="string">"doExceptionAction"</span>/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">"mycut"</span> <span class="attr">method</span>=<span class="string">“doReleaseAction</span>"/&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">"mycut"</span> <span class="attr">method</span>=<span class="string">"doBasicProfiling"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AOP是什么&quot;&gt;&lt;a href=&quot;#AOP是什么&quot; class=&quot;headerlink&quot; title=&quot;AOP是什么&quot;&gt;&lt;/a&gt;AOP是什么&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;面向方面编程（Aspect Oriented Programming）&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;Spring的一个关键的组件就是 AOP框架。 尽管如此，Spring IoC容器并不依赖于AOP，这意味着可以自由选择是否使用AOP，AOP提供强大的中间件解决方案，这使得Spring IoC容器更加完善。&lt;br&gt;&amp;emsp;&amp;emsp;Spring AOP的出现是为了取代EJB中的事务机制，它有这种声明式的事务机制，其实AOP的这种思想早就已经有了，并不是一种什么新的技术，也并不是说专门由java这里来实现的 。&lt;br&gt;&amp;emsp;&amp;emsp;面向切面编程（AOP）提供另外一种角度来思考程序结构，通&lt;br&gt;过这种方式弥补了面向对象编程（OOP）的不足。&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>依赖注入的实现（三）</title>
    <link href="http://www.normantriste.top/2017/10/28/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://www.normantriste.top/2017/10/28/依赖注入的实现（三）/</id>
    <published>2017-10-28T01:39:00.000Z</published>
    <updated>2017-11-06T08:33:44.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖注入的实现"><a href="#依赖注入的实现" class="headerlink" title="依赖注入的实现"></a>依赖注入的实现</h2><h3 id="解析IoC和DI"><a href="#解析IoC和DI" class="headerlink" title="解析IoC和DI"></a>解析IoC和DI</h3><h4 id="IOC："><a href="#IOC：" class="headerlink" title="IOC："></a>IOC：</h4><p>– Inversion of Control<br>– Dependency Injection<br><a id="more"></a></p><ul><li>IoC的直译是控制反转。  </li><li>在IoC模式下，控制权限从应用程序转移到了IoC容器中。组件  不是由应用程序负责创建和配置，而是由IoC容器负责。  </li><li>使用IoC的情况下，对象是被动地接收依赖类而不是主动地查找。对象不是从容器中查找他的依赖类，而是容器在实例化对象时，主动地将他所依赖的对象注入给他。  </li><li>应用程序只需要直接使用已经创建并且配置好的组件即可，而不必自己负责创建和配置。</li><li>在实际的工作中人们发现使用IoC来表述这种机制，并不是很准确甚至有些晦涩，于是引发了另外一个概念：DI(依赖注入)</li></ul><h4 id="DI解析"><a href="#DI解析" class="headerlink" title="DI解析"></a>DI解析</h4><p>&emsp;&emsp;之所以会产生组件调用，是为了获取被调用组件的功能，调用者将自己应该做的事情，委派给了被调用的对象。也就是说，调用者要完成自身的任务，必须依赖被调用的对象。<br>&emsp;&emsp;这种关系实际上就是一般依赖关系(通俗点说，就是一个组件内部包含另外一个组件的实例，把该自己干的事交给自己包含的组件去完成)。<br>&emsp;&emsp;因此IoC所表述的机制，实际上就是将调用者对接口实现类的依赖关系，从程序中移除，转交第三方管理实例。并且，由第三方在运行期间将调用者依赖的具体类填充进来。也就是说组件之间的依赖关系，是在程序运行期间由第三方来管理的。这个就是依赖注入的概念(DI)，基于上述分析，DI比IoC更准确。<br>&emsp;&emsp;实际上就是将调用者为完成功能所依赖的实现类，在程序运行期间，由容器自动填充给调用者，这个就是依赖注入的核心思想。在依赖注入的应用中，组件并不关心被注入的对象是谁，只关系这个对象能完成的功能，也就是这个对象是哪个接口的具体类实例。</p><h2 id="IoC的三种类型"><a href="#IoC的三种类型" class="headerlink" title="IoC的三种类型"></a>IoC的三种类型</h2><p>• 构造函数注入<br>&emsp;&emsp;– 所需信息通过构造函数参数注入<br>• 属性注入<br>&emsp;&emsp;– 所需信息通过属性的set方法注入<br>• 接口注入<br>&emsp;&emsp;– 实现接口，所需信息通过接口定义的方法注入。如EJB方式。</p><p><strong>Spring IOC支持构造函数注入和属性注入</strong><br>&emsp;&emsp;– 接口注入要求bean类实现接口，其入侵性强，与Spring设计初衷不符</p><h2 id="IoC容器的关键点："><a href="#IoC容器的关键点：" class="headerlink" title="IoC容器的关键点："></a>IoC容器的关键点：</h2><p>&emsp;&emsp;– 必须将被管理的对象定义在Spring的配置文件中<br>&emsp;&emsp;– 必须定义构造函数或setter方法，让spring将对象注入过来</p><h3 id="通过构造器注入"><a href="#通过构造器注入" class="headerlink" title="通过构造器注入"></a>通过构造器注入</h3> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  <span class="comment">&lt;!--</span></div><div class="line"><span class="comment">    通过构造器注入  </span></div><div class="line"><span class="comment">        index:参数的索引位置，从0开始</span></div><div class="line"><span class="comment">        name：参数名称</span></div><div class="line"><span class="comment">        ref：表示引用对象的id值</span></div><div class="line"><span class="comment">        value：非引用对象的值</span></div><div class="line"><span class="comment">    </span></div><div class="line"><span class="comment">    注意：</span></div><div class="line"><span class="comment">        1.构造函数的参数个数必须匹配</span></div><div class="line"><span class="comment">        2.构造函数的参数类型必须匹配</span></div><div class="line"><span class="comment">        3.建议保留默认无参构造函数</span></div><div class="line"><span class="comment">  --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address1"</span> <span class="attr">class</span>=<span class="string">"springse.p20.Address"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userConstruct"</span> <span class="attr">class</span>=<span class="string">"springse.p20.UserInfo"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- index="0"是可以缺省的 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"address1"</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="通过属性注入"><a href="#通过属性注入" class="headerlink" title="通过属性注入"></a>通过属性注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- </span></div><div class="line"><span class="comment">  通过属性注入 </span></div><div class="line"><span class="comment">      ref:表示引用对象的id值</span></div><div class="line"><span class="comment">      value：非引用对象的值</span></div><div class="line"><span class="comment">--&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"u1"</span> <span class="attr">class</span>=<span class="string">"springse.p20.UserInfo"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span> <span class="attr">depends-on</span>=<span class="string">"address1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address1"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address1"</span> <span class="attr">class</span>=<span class="string">"springse.p20.Address"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="属性标签"><a href="#属性标签" class="headerlink" title="属性标签"></a>属性标签</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">• value：基本类型（包装类型）或String类型</div><div class="line">• ref：引用类型，容器中其它的bean</div><div class="line">• list：List或数组类型</div><div class="line">• set：Set类型。用法与list类似。</div><div class="line">• map：Map类型</div><div class="line">• props：Properties类型，键值为String类型的，所以直接写</div><div class="line">值。</div></pre></td></tr></table></figure><h4 id="集合属性的用法"><a href="#集合属性的用法" class="headerlink" title="集合属性的用法"></a>集合属性的用法</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"listProperty"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>string value<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"foo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"setProperty"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>string value<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"foo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"bar"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapProperty"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"foo"</span>/&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propsProperty"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key1"</span>&gt;</span>bar1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key2"</span>&gt;</span>bar2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul><li>使用构造器注入</li><li>使用属性setter方法注入</li><li>使用Field注入（用于注解方式）</li><li>注入依赖对象可以采用手工装配或自动装配，在实际应用中建议使用手工装配，因为自动装配会产生未知情况,开发人员无法预见最终的装配结果。</li></ul><p><strong>1.手工装配依赖对象</strong><br><strong>2.自动装配依赖对象</strong></p><h3 id="依赖注入–手工装配"><a href="#依赖注入–手工装配" class="headerlink" title="依赖注入–手工装配"></a>依赖注入–手工装配</h3><h4 id="1-在xml配置文件中，通过在bean节点下配置，如"><a href="#1-在xml配置文件中，通过在bean节点下配置，如" class="headerlink" title="1. 在xml配置文件中，通过在bean节点下配置，如"></a>1. 在xml配置文件中，通过在bean节点下配置，如</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderService"</span> <span class="attr">class</span>=<span class="string">"cn.neusoft.service.OrderServiceBean"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span>//构造器注入</div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhao"</span>/&gt;</span>//属性setter方法注入</div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="2-注解方式："><a href="#2-注解方式：" class="headerlink" title="2. 注解方式："></a>2. 注解方式：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></div><div class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context</span></span></div><div class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">    这个配置隐式注册了多个对注释进行解析处理的处理器：</span></div><div class="line"><span class="comment">        AutowiredAnnotationBeanPostProcessor，</span></div><div class="line"><span class="comment">        CommonAnnotationBeanPostProcessor，</span></div><div class="line"><span class="comment">        PersistenceAnnotationBeanPostProcessor，</span></div><div class="line"><span class="comment">        RequiredAnnotationBeanPostProcessor</span></div><div class="line"><span class="comment">注： @Resource注解在spring安装目录的lib\j2ee\common-annotations.jar</span></div><div class="line"><span class="comment">--&gt;</span></div></pre></td></tr></table></figure><p>在java代码中使用@Autowired或@Resource注解方式进行装配，这两个注解的区别是：<br>@Autowired 默认按类型装配，<br>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span>    </div><div class="line"><span class="keyword">private</span> PersonDao personDao;<span class="comment">//用于字段上  </span></div><div class="line"><span class="meta">@Autowired</span>  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderDao</span><span class="params">(OrderDao orderDao)</span></span>&#123;<span class="comment">//用于属性的setter方法上  </span></div><div class="line">    <span class="keyword">this</span>.orderDao = orderDao;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>@Autowired注解是按类型装配依赖对象，默认情况下它要求依赖对象必须在，如果允许null值，可以设置它required属性为false。<br>如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@Qualifier注解表示@Autowired注解进行自动注入时，Spring 容器中匹配的候选Bean数目必须有且仅有一个。</span></div><div class="line"><span class="meta">@Autowired</span> <span class="meta">@Qualifier</span>(<span class="string">"personDaoBean"</span>)</div><div class="line"><span class="keyword">private</span> PersonDao personDao;</div></pre></td></tr></table></figure><p>&emsp;&emsp;在java代码中使用@Autowired或@Resource注解方式进行装配,<br>@Resource注解和@Autowired一样，也可以标注在字段或属性的setter方法上，但它默认按名称装配。<br>&emsp;&emsp;名称可以通过@Resource的name属性指定，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Resource</span>(name=“personDaoBean”)</div><div class="line"><span class="keyword">private</span> PersonDao personDao;<span class="comment">//用于字段上</span></div></pre></td></tr></table></figure><p>注意：如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时，@Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</p><h3 id="依赖注入–自动装配依赖对象-不推荐使用"><a href="#依赖注入–自动装配依赖对象-不推荐使用" class="headerlink" title="依赖注入–自动装配依赖对象(不推荐使用)"></a>依赖注入–自动装配依赖对象(不推荐使用)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span></div><div class="line">autowire属性取值如下：</div><div class="line">• byType：按类型装配，可以根据属性的类型，在容器中寻找跟该类型匹</div><div class="line">配的bean。如果发现多个，那么将会抛出异常。如果没有找到，即属性值</div><div class="line">为null。</div><div class="line">• byName：按名称装配，可以根据属性的名称，在容器中寻找跟该属性名</div><div class="line">相同的bean，如果没有找到，即属性值为null。</div><div class="line">• constructor与byType的方式类似，不同之处在于它应用于构造器参数。</div><div class="line">如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异</div><div class="line">常。</div><div class="line">• autodetect：通过bean类的自省机制（introspection）来决定是使用</div><div class="line">constructor还是byType方式进行自动装配。如果发现默认的构造器，那么</div><div class="line">将使用byType方式。</div></pre></td></tr></table></figure><h3 id="自动扫描"><a href="#自动扫描" class="headerlink" title="自动扫描"></a>自动扫描</h3><p><strong>通过在classpath自动扫描方式把组件纳入spring容器中管理</strong><br>&emsp;&emsp;前面的例子我们都是使用XML的bean定义来配置组件。在一个稍大的项目中，通常会有上百个组件，如<br>果这些这组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找及维护起来也不太方便。<br>spring2.5为我们引入了组件自动扫描机制，他可以在类路径底下寻找标注了@Component、@Service、@Controller、@Repository注解的类，并把这些类纳入进spring容器中管理。它的作用和在xml文件中使用bean节点配置组件是一样的。要使用自动扫描机制，我们需要打开以下配置信息:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></div><div class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></div><div class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></div><div class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></div><div class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context-2.5.xsd"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"springse.p20_2;"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div><div class="line">其中base-package为需要扫描的包(含子包)。</div></pre></td></tr></table></figure></p><p>对应的对象信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> springse.p20_2;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> id;</div><div class="line">String name;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"创建student对象！"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</div><div class="line"><span class="keyword">super</span>();</div><div class="line"><span class="keyword">this</span>.id = id;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> id;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.id = id;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"Student [id="</span> + id + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>@Service用于标注业务层组件、 @Controller用于标注控制层组件（如struts中的action）、@Repository用于标注数据访问组件，即DAO组件。而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;依赖注入的实现&quot;&gt;&lt;a href=&quot;#依赖注入的实现&quot; class=&quot;headerlink&quot; title=&quot;依赖注入的实现&quot;&gt;&lt;/a&gt;依赖注入的实现&lt;/h2&gt;&lt;h3 id=&quot;解析IoC和DI&quot;&gt;&lt;a href=&quot;#解析IoC和DI&quot; class=&quot;headerlink&quot; title=&quot;解析IoC和DI&quot;&gt;&lt;/a&gt;解析IoC和DI&lt;/h3&gt;&lt;h4 id=&quot;IOC：&quot;&gt;&lt;a href=&quot;#IOC：&quot; class=&quot;headerlink&quot; title=&quot;IOC：&quot;&gt;&lt;/a&gt;IOC：&lt;/h4&gt;&lt;p&gt;– Inversion of Control&lt;br&gt;– Dependency Injection&lt;br&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>接口（二续）</title>
    <link href="http://www.normantriste.top/2017/10/28/%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%8C%E7%BB%AD%EF%BC%89/"/>
    <id>http://www.normantriste.top/2017/10/28/接口（二续）/</id>
    <published>2017-10-28T01:34:00.000Z</published>
    <updated>2017-11-06T08:34:00.064Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Aware相关接口-不建议使用"><a href="#一、Aware相关接口-不建议使用" class="headerlink" title="一、Aware相关接口(不建议使用)"></a>一、Aware相关接口(不建议使用)</h4><p><strong>BeanNameAware接口:</strong><br>bean可以在初始化时获得容器中定义的名字<br><strong>BeanFactoryAware接口:</strong><br>BeanFactory容器的bean得到spring容器的引用<br><strong>ApplicationContextAware接口:</strong><br>ApplicationContext容器的bean得到Spring容器的引用</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h4 id="二、Processor相关接口-不建议使用"><a href="#二、Processor相关接口-不建议使用" class="headerlink" title="二、Processor相关接口(不建议使用)"></a>二、Processor相关接口(不建议使用)</h4><p><strong>BeanPostProcessor接口</strong><br>在bean加载后，对Bean做一些后处理工作<br><strong>BeanFactoryPostProcessor接口</strong><br>在Bean工厂载入所有Bean的 定义后，初始化Bean之前，对Bean工厂做的一些后处理工作</p><hr><h4 id="三、分散配置-不建议使用"><a href="#三、分散配置-不建议使用" class="headerlink" title="三、分散配置(不建议使用)"></a>三、分散配置(不建议使用)</h4><p><strong>用于读取外部文件，比如  读取数据库配置文件  挺常用的</strong><br><strong>PropertyPlaceholderConfiurer接口</strong></p><ul><li>将属性值的设置分离出Bean的定义文件，放置到其他配置文件中进行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">## db.properties ##</div><div class="line">jdbc.driverClassName = oracle.jdbc.driver.OracleDriver</div><div class="line">jdbc.url = jdbc:oracle:thin:@localhost:1521:orcl</div><div class="line">jdbc.username = xxxx</div><div class="line">hdbc.password = xxxx</div></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DBUtil.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span></span>&#123;</div><div class="line">        DBUtil.dataSource = dataSource;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获取数据库连接</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span></span>&#123;</div><div class="line">        Connection conn = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">           conn = dataSource.getConnection(); </div><div class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> conn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--  </span></div><div class="line"><span class="comment">    导jar包：</span></div><div class="line"><span class="comment">            1. spring-jdbc-4.1.7.RELEASE.jar</span></div><div class="line"><span class="comment">            2.jdbc6.jar   jdbc连接数据库 </span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="comment">&lt;!--获取数据源--&gt;</span></div></pre></td></tr></table></figure><p><strong>ResourceBundleMessageSource接口</strong></p><ul><li>将消息资源进行绑定</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Aware相关接口-不建议使用&quot;&gt;&lt;a href=&quot;#一、Aware相关接口-不建议使用&quot; class=&quot;headerlink&quot; title=&quot;一、Aware相关接口(不建议使用)&quot;&gt;&lt;/a&gt;一、Aware相关接口(不建议使用)&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;BeanNameAware接口:&lt;/strong&gt;&lt;br&gt;bean可以在初始化时获得容器中定义的名字&lt;br&gt;&lt;strong&gt;BeanFactoryAware接口:&lt;/strong&gt;&lt;br&gt;BeanFactory容器的bean得到spring容器的引用&lt;br&gt;&lt;strong&gt;ApplicationContextAware接口:&lt;/strong&gt;&lt;br&gt;ApplicationContext容器的bean得到Spring容器的引用&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>bean实例化（二）</title>
    <link href="http://www.normantriste.top/2017/10/27/Spring%E6%A1%86%E6%9E%B6-IOC%E5%AE%B9%E5%99%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://www.normantriste.top/2017/10/27/Spring框架-IOC容器（二）/</id>
    <published>2017-10-27T06:01:00.000Z</published>
    <updated>2017-11-06T08:34:16.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h2><h3 id="用构造器来实例化："><a href="#用构造器来实例化：" class="headerlink" title="用构造器来实例化："></a>用构造器来实例化：</h3><p>&emsp;&emsp;需要指定class属性(常用)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--IUserDao userDao = new UserDaoImpl();--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"spring.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p><a id="more"></a><h3 id="使用静态工厂方法实例化："><a href="#使用静态工厂方法实例化：" class="headerlink" title="使用静态工厂方法实例化："></a>使用静态工厂方法实例化：</h3><p>&emsp;&emsp;需要指定class属性外，还需要通过factory-method属性来指定创建bean实例的工厂方法<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">DaoStaticFactory:工厂类</span></div><div class="line"><span class="comment">createUserDao()：用于是实例化UserDao的工厂方法</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">IUserDao userDao2 = DaoStaticFactory.createUserDao();</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao2"</span> <span class="attr">class</span>=<span class="string">"spring.DaoStaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="使用实例工厂方法实例化："><a href="#使用实例工厂方法实例化：" class="headerlink" title="使用实例工厂方法实例化："></a>使用实例工厂方法实例化：</h3><p>&emsp;&emsp;class属性必须为空，而factory-bean属性必须指定为当前（或其祖先）容器中包含工厂方法的bean的名称，而该工厂bean的工厂方法本身必须通过factory-method属性来设定;<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">DaoNonStaticFactory factory = new DaoNonStaticFactory();</span></div><div class="line"><span class="comment">IuserDao userDao3 = factory.createUserDao();</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"factory"</span> <span class="attr">class</span>=<span class="string">"spring.DaoNonStaticFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao3"</span> <span class="attr">factory-bean</span>=<span class="string">"factory"</span> <span class="attr">factory-method</span>=<span class="string">"createUserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="singleton、prototype"><a href="#singleton、prototype" class="headerlink" title="singleton、prototype"></a>singleton、prototype</h3><p>1.没有自己私有的属性的都是无状态的<br>2.封装方法的类时可以用单例的<br>3.service类基本都是单例的，而如Student类包含个性的私有的属性的类应当使用原型（prototype）<br>4.单例调用非单例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> spring;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> IUserDao dao = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDao</span><span class="params">(IUserDao dao)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"UserService.setDao("</span>+dao+<span class="string">")"</span>);</div><div class="line">        <span class="keyword">this</span>.dao = dao;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> IUserDao get <span class="title">Dao</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> dao;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUser</span><span class="params">()</span></span>&#123;</div><div class="line">        dao.selectUser();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--非单例模式--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"spring.UserDaoImpl"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--单例模式--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"spring.UserService"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--</span></div><div class="line"><span class="comment">    lookup-method:一般用于单例引用非单例对象的情况</span></div><div class="line"><span class="comment">        name:指定方法名称</span></div><div class="line"><span class="comment">        bean:指定返回值类型</span></div><div class="line"><span class="comment">        --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"getDao"</span> <span class="attr">bean</span>=<span class="string">"userDao"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="lazy-init"><a href="#lazy-init" class="headerlink" title="lazy-init"></a>lazy-init</h3><p>&ensp;&ensp;不需要直接new出来的，用的不是特别的，可以配置成懒加载<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">default-lazy-init="true":全局配置，对当前文档所有bean生效</div><div class="line">lazy-init="true"</div><div class="line">懒加载，默认值false</div><div class="line">注意：当非懒加载bean依赖（引用）懒加载bean时，懒加载bean配置无效</div></pre></td></tr></table></figure></p><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">parent：表示继承关系</span></div><div class="line"><span class="comment">    1.复用父类属性</span></div><div class="line"><span class="comment">    2.覆盖父类属性</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line">例如：</div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"animal"</span> <span class="attr">class</span>=<span class="string">"spring.Animal"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"spring.Dao"</span> <span class="attr">parent</span>=<span class="string">"animal"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;bean实例化&quot;&gt;&lt;a href=&quot;#bean实例化&quot; class=&quot;headerlink&quot; title=&quot;bean实例化&quot;&gt;&lt;/a&gt;bean实例化&lt;/h2&gt;&lt;h3 id=&quot;用构造器来实例化：&quot;&gt;&lt;a href=&quot;#用构造器来实例化：&quot; class=&quot;headerlink&quot; title=&quot;用构造器来实例化：&quot;&gt;&lt;/a&gt;用构造器来实例化：&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;需要指定class属性(常用)&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--IUserDao userDao = new UserDaoImpl();--&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;userDao&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;spring.UserDaoImpl&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>IOC容器（一）</title>
    <link href="http://www.normantriste.top/2017/10/25/Spring%E6%A1%86%E6%9E%B6-IOC%E5%AE%B9%E5%99%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://www.normantriste.top/2017/10/25/Spring框架-IOC容器（一）/</id>
    <published>2017-10-25T07:47:00.000Z</published>
    <updated>2017-11-06T08:34:28.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ioc-控制反转-依赖注入-容器"><a href="#Ioc-控制反转-依赖注入-容器" class="headerlink" title="Ioc(控制反转/依赖注入)容器"></a>Ioc(控制反转/依赖注入)容器</h2><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>(建议使用这种方式获取容器)<br>1.继承了BeanFactory接口，是BenaFactory功能的延展<br>2.尽可能早的初始化Bean<br>3.支持国际化<br>4.支持事件监听机制<br>5.提供通用的方式获取资源</p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="Bean是什么？"><a href="#Bean是什么？" class="headerlink" title="Bean是什么？"></a>Bean是什么？</h3><blockquote><p>具有唯一id的Simple Object<br>由IOC容器管理其生命周期及其依赖关系</p><ul><li>简单的讲，bean就是由Spring容器初始化、装配及被管理的对象</li><li>bean定义以及bean相互之间的依赖关系将通过配置元数据来描述</li><li>一般在xml文件中定义<br>bean定义与应用程序中实际使用的对象一一对应。通常情况下bean的定义包括：</li><li>服务层对象service</li><li>数据访问层对象（Dao）</li><li>类似Struts Action的表示层对象 servlet</li><li>Hibernate SessionFactory对象等等</li><li>项目的复杂程度将决定bean定义的多寡</li></ul><hr></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- </span></div><div class="line"><span class="comment">    配置dao:IUserDao dao = new UserDaoImpl()</span></div><div class="line"><span class="comment">    id:属性值必须唯一(相当于引用对象的名称)</span></div><div class="line"><span class="comment">    class:完整的路径名称，包名+类名，确保按ctrl+鼠标左键，可以点击进入定义类</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao"</span> <span class="attr">class</span>=<span class="string">"spring.UserDaoImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dao2"</span> <span class="attr">class</span>=<span class="string">"spring.UserDaoImpl2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--</span></div><div class="line"><span class="comment">    配置service：UserService sewrvice = new UserService();</span></div><div class="line"><span class="comment">        service.setDao(dao2);</span></div><div class="line"><span class="comment">--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"service"</span> <span class="attr">class</span>=<span class="string">"spring.UserService"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dao"</span> <span class="attr">ref</span>=<span class="string">"dao2"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></div><div class="line">注意：第一个dao是setDao中的属性dao,第二个dao为上面配置的dao中的bean的id</div></pre></td></tr></table></figure><h4 id="导入配置文件的主要方式"><a href="#导入配置文件的主要方式" class="headerlink" title="导入配置文件的主要方式"></a>导入配置文件的主要方式</h4><p><strong>一、ClassPathXmlApplicationContext</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">1.ClassPathXmlApplicationContext:</div><div class="line">从类路径下的Xml文件中载入上下文定义信息  </div><div class="line">2.FileSystemXmlApplicationContext:</div><div class="line">从文件载入上下文定义信息  </div><div class="line">3.XmlWebApplicationContext:</div><div class="line">通过ContextLoaderListener从内部导入文件</div><div class="line">3.1 WebAppicationContext</div><div class="line">通过ContextLoaderListener从内部导入文件</div></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用方式</span></div><div class="line"><span class="comment">//1.装载并解析applicationContext.xml配置文件</span></div><div class="line">BeanFactory factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</div><div class="line"><span class="comment">//2.获取service对象</span></div><div class="line">service.findUser();</div><div class="line"></div><div class="line">注意:运行时抛出java.lang.ClassNotFoundException:org.apache.commons.logging.LOgFactory</div><div class="line">导入依赖包commons-logging.jar</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 装载并解析applicationContext.xml配置文件</span></div><div class="line"><span class="number">1</span>.ClassPathXmlApplicationContext 从类路径下的XML文件中载入上下文定义信息-----推荐使用</div><div class="line">- 单个配置文件读取</div><div class="line">BeanFactory factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</div><div class="line">BeanFactory factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config/applicationContext_1.xml"</span>);</div><div class="line">- 多个配置文件读取</div><div class="line">BeanFactory factory = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"applicationContext.xml"</span>,<span class="string">"config/applicationContext_1.xml"</span>&#125;);</div></pre></td></tr></table></figure><p><strong>二、FileSystemXmlApplicationContext</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从文件系统路径下的XML文件中载入上下文定义信息</span></div><div class="line"><span class="comment">//①相对路径</span></div><div class="line">BeanFactory factory = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"config/applictionContext.xml"</span>);</div><div class="line"><span class="comment">//②绝对路径</span></div><div class="line">BeanFactory factory = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"G:\\xxx\\xx\\config/applictionContext.xml"</span>);</div></pre></td></tr></table></figure><p><strong>三、WebApplicationContext</strong><br>通过ContextLoaderListener从内部导入context文件<br>&emsp;&emsp;==Web环境，需要导入spring-web.jar包==<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">XmlWebApplicationContext factory = <span class="keyword">new</span> XmlWebApplicationContext();</div><div class="line"><span class="comment">//配置application应用环境</span></div><div class="line">factory.setServletContext(request.getServletContext());</div><div class="line"><span class="comment">//默认的配置文件路/WEB-INF/applicationContext.xml</span></div><div class="line">factory.setConfigLocation(<span class="string">"此处填入相对路径"</span>);</div><div class="line"><span class="comment">//刷新</span></div><div class="line">factory.refresh();</div></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//WebApplicationContext</div><div class="line">//通过ContextLoaderListener从内部导入context文件</div><div class="line">WebApplicationContext factory = WebApplicationContextUtils.getRequiredWebAppplicationContext(request.getServletContext());</div><div class="line"><span class="comment">&lt;!--在Web.xml中注册监听器：--&gt;</span></div><div class="line"> 1.spring配置文件路径</div><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div><div class="line">2.监听器</div><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></div><div class="line">        org.springframework.web.context.ContextLoaderListener</div><div class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Ioc-控制反转-依赖注入-容器&quot;&gt;&lt;a href=&quot;#Ioc-控制反转-依赖注入-容器&quot; class=&quot;headerlink&quot; title=&quot;Ioc(控制反转/依赖注入)容器&quot;&gt;&lt;/a&gt;Ioc(控制反转/依赖注入)容器&lt;/h2&gt;&lt;h3 id=&quot;ApplicationContext&quot;&gt;&lt;a href=&quot;#ApplicationContext&quot; class=&quot;headerlink&quot; title=&quot;ApplicationContext&quot;&gt;&lt;/a&gt;ApplicationContext&lt;/h3&gt;&lt;p&gt;(建议使用这种方式获取容器)&lt;br&gt;1.继承了BeanFactory接口，是BenaFactory功能的延展&lt;br&gt;2.尽可能早的初始化Bean&lt;br&gt;3.支持国际化&lt;br&gt;4.支持事件监听机制&lt;br&gt;5.提供通用的方式获取资源&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="框架" scheme="http://www.normantriste.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.normantriste.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题收录1</title>
    <link href="http://www.normantriste.top/2017/10/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%951/"/>
    <id>http://www.normantriste.top/2017/10/01/Java面试题收录1/</id>
    <published>2017-10-01T12:18:00.000Z</published>
    <updated>2017-10-27T12:48:42.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面试要了解的问题"><a href="#面试要了解的问题" class="headerlink" title="面试要了解的问题"></a>面试要了解的问题</h3><p>简单介绍一下您的情况？<br>您怎样描述自己？<br>您为何要选择我公司？<br>您为了这次面试做了哪些准备工作？<br>我们为什么要雇佣您？<br>为什么您要应聘这个职位？<br>您期望的薪金待遇是多少？<br><a id="more"></a><br>什么对您来说更加重要 — 工作还是金钱？<br>您期望从此职业中获得什么 — 金钱、声望还是事业成就感？<br>如果其他公司为您提供了更高的薪水，您会离开我公司吗？<br>您生活的最终目标是什么？<br>您怎样做好准备来实现这些目标？<br>您为何选择这类职业？<br>除了计算机之外，您还有什么其它兴趣？<br>您有哪些强项？<br>您的弱点有哪些？<br>您认为您能在我们公司发挥所长吗<br>以前您是否经常变换工作地点？<br>您为何要离开以前的工作单位？<br>您上一个工作的职责是什么？<br>您上一个工作的薪水是多少？<br>为什么计算机突然之间变得如此重要？<br>为什么您感觉需要学习计算机？<br>您认为计算机会使人们变得无用吗？<br>计算机在未来的某个时候会发展到能够思考吗？  </p><h3 id="专业知识问答："><a href="#专业知识问答：" class="headerlink" title="专业知识问答："></a>专业知识问答：</h3><p>1.如何实现线程?<br>2.JSP应用中,重定向有些什么方法?<br>3.JSP的对象Request中的getparameter方法与session对象中的getAttribute方法的区别?(两对象应用之间的区别?)<br>4.如何加入Session对象?<br>5.Java开发包有些什么开发工具?<br>6.如何实现Jsp页面与数据库的连接(jdbc-odbc桥)?实现连接时要用到哪些类?<br>7.如何构造List对象,用什么方法插入和取得List项目中数据项?<br>8.Session的生命期多长?(参阅Session对象的一些属性设置)<br>9.简述你所熟悉的一些web server.<br>10.如果要使一个程序在网络上传接,要实现什么接口?<br>11.JDBC中如何控制一个事务？<br>12.如何实现JSP程序参数之间的传递？  </p><h3 id="主要知识点：（请做答）"><a href="#主要知识点：（请做答）" class="headerlink" title="主要知识点：（请做答）"></a>主要知识点：（请做答）</h3><p>1、Java的基本数据类型<br>2、ava语言的优点<br>3、字符及字符串和其他数据类型之间的转换<br>4、对象和类的概念，类的继承、重载、多态<br>5、类的访问控制及其区别<br>6、接口和抽象类的概念及区别<br>7、集合的概念及几种类型，基类及接口<br>8、简单的数据的存储过程<br>9、JDBC创建的几个步骤<br>10、Statement、PrepareStatement、CallableStatement区别<br>11、Socket网络连接&lt;一般都是服务端&gt;<br>12、I/O接口的几种类型<br>13、JSP与Servlet的区别<br>14、JSP的内置对象及作用域<br>15、JSP和Servlet的页面转发和控制的区别<br>16、Servlet的生命周期<br>17、Web框架  </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1、编程语言基本概念（编程风格和语言概念是考察的重点内容）。<br>2、数据结构（这是计算机编程的基础，肯定是必考的，但是在一个小时内不可能会考复杂的算法，主要是考察您的解决问题的思路）。<br>3、网络（最基本的要掌握TCP/IP，包括协议原理和编程）<br>4、操作系统（考一些基本的概念如进程调度，内存管理等）</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面试要了解的问题&quot;&gt;&lt;a href=&quot;#面试要了解的问题&quot; class=&quot;headerlink&quot; title=&quot;面试要了解的问题&quot;&gt;&lt;/a&gt;面试要了解的问题&lt;/h3&gt;&lt;p&gt;简单介绍一下您的情况？&lt;br&gt;您怎样描述自己？&lt;br&gt;您为何要选择我公司？&lt;br&gt;您为了这次面试做了哪些准备工作？&lt;br&gt;我们为什么要雇佣您？&lt;br&gt;为什么您要应聘这个职位？&lt;br&gt;您期望的薪金待遇是多少？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.normantriste.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Java面试" scheme="http://www.normantriste.top/tags/Java%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>华为面试题收录1</title>
    <link href="http://www.normantriste.top/2017/10/01/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%951/"/>
    <id>http://www.normantriste.top/2017/10/01/华为面试题收录1/</id>
    <published>2017-10-01T12:01:00.000Z</published>
    <updated>2017-10-27T12:49:14.609Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1 面向对象的特征有哪些方面</strong><br><strong>2 String是最基本的数据类型吗?</strong><br><strong>3 int 和 Integer 有什么区别？</strong><br><strong>4 String 和StringBuffer的区别？</strong><br><strong>5 运行时异常与一般异常有何异同？</strong><br><a id="more"></a><br>  异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。<br><strong>6 说出一些常用的类，包,接口，请各举5个</strong><br><strong>7 说出ArrayList,Vector, LinkedList的存储性能和特性</strong><br>  ArrayList和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。<br><strong>8 设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1,写出程序。<br>以下程序使用内部类实现线程，对j增减的时候没有考虑顺序问题。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> j;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">ThreadTest1 tt = <span class="keyword">new</span> ThreadTest1();</div><div class="line">Inc inc = tt.new Inc();</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</div><div class="line">Thread t = <span class="keyword">new</span> Thread(inc);</div><div class="line">t.start();</div><div class="line">t = <span class="keyword">new</span> Thread(dec);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">j++;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"-inc:"</span> + j);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span> </span>&#123;</div><div class="line">j--;</div><div class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"-dec:"</span> + j);</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inc</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">inc();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dec</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">dec();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>9．JSP的内置对象及方法。</strong><br>  request   request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。<br>  response response表示HttpServletResponse对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）<br>  out<br>  &emsp;&emsp;out 对象是javax.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。<br>  pageContext<br>  &emsp;&emsp;pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。<br>  session<br>  &emsp;&emsp;session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息<br>  application<br>  &emsp;&emsp;applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息<br>  config<br>  &emsp;&emsp;config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。<br>  page<br>  &emsp;&emsp;page表示从该页面产生的一个servlet实例<br><strong>10 用socket通讯写出客户端和服务器端的通讯，要求客户发送数据后能够回显相同的数据。(参见课程中socket通讯例子)</strong><br><strong>11 说出Servlet的生命周期，并说出Servlet和CGI的区别。</strong><br>  Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy方法。<br>  与cgi的区别在于servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于servlet。<br><strong>12 EJB是基于哪些技术实现的?并说出SessionBean和EntityBean的区别，StatefulBean和StatelessBean的区别。</strong><br><strong>13．EJB包括（SessionBean,EntityBean）说出他们的生命周期，及如何管理事务的？</strong><br><strong>14．说出数据连接池的工作机制是什么? </strong><br><strong>15同步和异步有和异同，在什么情况下分别使用他们？举例说明。</strong><br><strong>16 应用服务器有那些？</strong><br><strong>17 你所知道的集合类都有哪些？主要方法？</strong><br><strong>18 给你一个:驱动程序A,数据源名称为B,用户名称为C,密码为D,数据库表为T，请用JDBC检索出表T的所有数据。</strong><br><strong>19 说出在JSP页面里是怎么分页的? </strong><br>页面需要保存以下参数：<br> 1)总行数：根据sql语句得到总行数<br> 2)每页显示行数：设定值<br> 3)当前页数：请求参数<br> 4)页面根据当前页数和每页行数计算出当前页第一行行数，定位结果集到此行，对结果集取出每页显示行数的行即可。<br>数据库方面<br><strong>1.存储过程和函数的区别</strong><br>  存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。<br><strong>2.事务是什么？</strong><br>  事务是作为一个逻辑单元执行的一系列操作，一个逻辑工作单元必须有四个属性，称为 ACID（原子性、一致性、隔离性和持久性）属性，只有这样才能成为一个事务：<br> 原子性<br>  事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。<br> 一致性<br>  事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。<br> 隔离性<br>  由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为可串行性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。<br> 持久性<br>  事务完成之后，它对于系统的影响是永久性的。该修改即使出现系统故障也将一直保持。<br><strong>3.游标的作用？如何知道游标已经到了最后？</strong><br>  游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。<br><strong>4.触发器分为事前触发和事后触发，这两种触发有和区别。语句级触发和行级触发有何区别。</strong><br>  事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1 面向对象的特征有哪些方面&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2 String是最基本的数据类型吗?&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;3 int 和 Integer 有什么区别？&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4 String 和StringBuffer的区别？&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;5 运行时异常与一般异常有何异同？&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.normantriste.top/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.normantriste.top/tags/Java/"/>
    
      <category term="Java面试" scheme="http://www.normantriste.top/tags/Java%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
